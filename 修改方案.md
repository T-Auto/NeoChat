好的，这是一个非常棒的增强功能提议！它极大地提升了剧情创作者对自由对话环节的控制力。

根据你的需求，我为你准备了一份详细的项目修改方案书，以及一份更新后的“剧情创作指南”草案。

---

## NeoChat 自由时间模式增强方案书

### 1. 项目目标

对 `core/game_engine.py` 中的自由时间（`FreeTime` 和 `LimitedFreeTime`）处理逻辑进行修改，以实现以下功能：

1.  **支持指定对话角色**：剧情创作者可以在 YAML 剧本中为自由时间环节指定一个或多个参与对话的 AI 角色。
2.  **支持指定对话顺序**：如果指定了多个 AI 角色，系统将严格按照创作者定义的顺序进行轮流回复。
3.  **兼容默认行为**：如果创作者未指定任何角色，系统应回退到当前默认行为，即与剧本中的所有 AI 角色进行轮流对话。

### 2. 技术实现方案

核心修改将集中在 `core/game_engine.py` 文件，并需要对剧情 `EndCondition` 的 YAML 格式进行扩展。

#### 2.1 YAML 剧情文件格式扩展

我们需要在 `FreeTime` 和 `LimitedFreeTime` 类型的 `EndCondition` 中增加一个新的可选字段：`InteractWith`。

-   **字段名**: `InteractWith`
-   **类型**: 列表 (List of strings)
-   **内容**: 列表中包含一个或多个 AI 角色的 `role_id` (例如，在 `全局剧情配置.yaml` 中定义的 `character_roles` 里的ID)。
-   **行为**:
    -   如果提供了此字段，自由时间将只包含列表中的角色，并按列表顺序轮流。
    -   如果未提供此字段，则使用 `全局剧情配置.yaml` 中 `character_roles` 的全部角色进行轮流。

**示例 YAML:**

```yaml
# 示例1: 只和 Roxy 对话
EndCondition:
  Type: FreeTime
  InstructionToPlayer: "现在你可以和 Roxy 自由交谈，聊够了输入 '继续剧情' 来推进故事。"
  ExitPromptInInputBox: "继续剧情"
  NextUnitID: "unit_after_roxy_talk"
  InteractWith:
    - "Roxy" # 角色 role_id

# 示例2: 按照 Yuki -> Roxy 的顺序轮流对话
EndCondition:
  Type: LimitedFreeTime
  MaxTurns: 5
  InstructionToPlayer: "你现在有5个回合的时间可以和 Yuki、Roxy 聊聊。"
  NextUnitID: "unit_after_group_talk"
  InteractWith:
    - "Yuki"
    - "Roxy"
```

#### 2.2 `core/game_engine.py` 代码修改

需要修改两个关键函数：`_process_end_condition` 和 `provide_player_input`。

##### **A. 修改 `_process_end_condition` 函数**

**目标**：当进入自由时间状态时，检查 `EndCondition` 中是否存在 `InteractWith` 字段，如果存在，则将其存入 `progress['free_time_context']` 中，供后续使用。

**定位**：`_process_end_condition` 函数内 `elif end_type == 'FreeTime' or end_type == 'LimitedFreeTime':` 的代码块。

```python
# game_engine.py -> _process_end_condition()

        elif end_type == 'FreeTime' or end_type == 'LimitedFreeTime':
            self.progress['runtime_state'] = 'InFreeTime'
            self.progress['free_time_context'] = {
                'end_condition': end_data,
                'turns_taken': 0,
                # --- [新增代码] ---
                # 检查并存储指定的互动角色列表
                'interact_with_list': end_data.get('InteractWith') 
            }
            log_info_color(self._format_string(end_data['InstructionToPlayer']), TermColors.BLUE)
```

**修改说明**:
我们使用 `.get('InteractWith')` 来安全地获取 `InteractWith` 列表。如果该字段不存在，`get()` 会返回 `None`，这正是我们想要的默认行为标记。这个列表被存储在 `free_time_context` 中，以便 `provide_player_input` 函数可以访问它。

##### **B. 修改 `provide_player_input` 函数**

**目标**: 在处理自由时间的玩家输入时，根据 `free_time_context` 中是否存在指定的角色列表来决定由哪个 AI 回复。

**定位**: `provide_player_input` 函数内 `elif state == 'InFreeTime':` 的代码块。

```python
# game_engine.py -> provide_player_input()

        elif state == 'InFreeTime':
            context = self.progress['free_time_context']
            end_condition = context['end_condition']
            exit_prompt = self._format_string(end_condition.get('ExitPromptInInputBox', ''))

            if exit_prompt and exit_prompt in text:
                log_info("检测到退出语，自由时间结束。")
                self._transition_to_unit(end_condition['NextUnitID'])
                self.run()
                return

            # --- 新增: 将玩家的输入存入运行时上下文 ---
            self.runtime_context['player_input'] = text
            
            self._add_to_dialogue_history('Player', content=text)
            
            # --- [核心修改开始] ---
            # AI 回复 - 使用新的智能轮询机制

            # 1. 决定本次自由时间的对话角色列表
            # 首先尝试从上下文中获取指定的角色列表
            characters_for_freerime = context.get('interact_with_list') 
            
            # 如果没有指定列表，则回退到默认行为：使用全局配置中的所有角色
            if not characters_for_freerime:
                # 优先选择DM角色
                dm_char_id = self.global_config.get('dm_role_id')
                if dm_char_id and dm_char_id in self.character_files:
                    characters_for_freerime = [dm_char_id]
                else:
                    characters_for_freerime = self.global_config['character_roles']
            
            # 如果列表为空，则记录警告并跳过AI回复
            if not characters_for_freerime:
                log_warning("自由时间中没有可用的AI角色进行对话。")
                return

            # 2. 从列表中选择下一个发言的角色
            last_responder_index = self.progress.get('last_responder_index', -1)
            next_responder_index = (last_responder_index + 1) % len(characters_for_freerime)
            ai_char_id = characters_for_freerime[next_responder_index]
            self.progress['last_responder_index'] = next_responder_index  # 记录本次响应者索引
            
            # --- [核心修改结束] ---

            ai_char_name = self.character_files[ai_char_id]['name']

            # --- 修复点：格式化AI角色prompt中的模板变量 ---
            ai_system_prompt = self._format_string(self.character_files[ai_char_id]['prompt'])
            messages = [{"role": "system", "content": ai_system_prompt}]
            # ... (后续的 messages 构建和 chat_with_deepseek 调用逻辑保持不变) ...
```

**修改说明**:
1.  **获取对话列表**: 我们首先尝试从 `context` 中获取 `interact_with_list`。
2.  **回退逻辑**: 如果列表不存在（为 `None` 或空），代码将执行原有的逻辑，即检查 DM 或使用全局配置中的所有角色。
3.  **轮询机制**: 现有基于 `last_responder_index` 的轮询机制被完美复用，它现在作用于我们新确定的 `characters_for_freerime` 列表。无论是指定的顺序列表还是默认的全体角色列表，这个机制都能正确工作。

### 3. 实施步骤

1.  **备份项目**：在进行任何修改之前，备份整个 `NeoChat` 项目文件夹。
2.  **修改代码**：将上述代码片段应用到 `core/game_engine.py` 文件中。
3.  **更新剧本**：在你选择的一个 `story_packs`（例如 `campus_love_comedy`）中，找一个剧情单元，将其 `EndCondition` 修改为新的 `FreeTime` 格式，并添加 `InteractWith` 字段进行测试。
4.  **测试**：
    -   运行一个使用了 `InteractWith` 的新剧本，验证是否只有指定的角色按指定顺序回复。
    -   运行一个未修改的旧剧本，验证其自由时间功能是否仍然正常（即所有角色轮流回复），确保向后兼容性。

### 4. 预期效果

-   剧情创作者可以精确控制自由对话环节的参与者和节奏。
-   可以创造出更丰富的互动场景，如“与A的私密对话”、“按顺序向B、C、A汇报情况”等。
-   项目保持了对旧版本剧本的完全兼容。

---

## 《NeoChat 剧情创作指南》更新草案

（将此部分内容添加或替换到现有指南中关于 `EndCondition` 的章节）

### **EndCondition: 剧情单元的终点**

`EndCondition` 定义了一个剧情单元所有 `Events` 执行完毕后会发生什么。

#### **类型 (Type): `FreeTime` / `LimitedFreeTime`**

这是游戏中非常强大的功能，它允许游戏暂停预设的事件流，让玩家与一个或多个 AI 角色进行自由对话。

-   `FreeTime`: 无限轮次的自由对话，直到玩家输入特定的退出指令。
-   `LimitedFreeTime`: 有固定轮次限制的自由对话。

**通用参数:**
-   `InstructionToPlayer` (str): 进入自由时间时，向玩家显示的提示语。
-   `NextUnitID` (str): 自由时间结束后，游戏将跳转到的下一个剧情单元ID。
-   `MaxTurns` (int, 仅用于 `LimitedFreeTime`): 自由对话的最大玩家输入轮次。
-   `ExitPromptInInputBox` (str, 仅用于 `FreeTime`): 玩家需要输入的、用于结束自由时间的特定指令。

#### **【新功能】指定自由时间的对话角色**

默认情况下，自由时间会让玩家与剧本中定义的所有 AI 角色轮流对话。现在，你可以通过 `InteractWith` 参数来精确控制参与对话的角色和顺序。

-   **参数**: `InteractWith`
-   **类型**: 列表 (List)
-   **说明**: 一个包含角色ID（`role_id`）的列表。自由对话将严格限制在这些角色内，并按照列表中的顺序进行轮流。如果省略此参数，则恢复为与所有角色对话的默认行为。

**使用示例:**

**场景1：在侦探故事中，你只能单独审问嫌疑人A**

```yaml
# ... Events ...
EndCondition:
  Type: FreeTime
  InstructionToPlayer: "现在你可以开始审问嫌疑人A了。问完所有问题后，输入'审问结束'离开房间。"
  ExitPromptInInputBox: "审问结束"
  NextUnitID: "select_next_suspect_unit"
  InteractWith:
    - "Suspect_A" # 假设 "Suspect_A" 是在全局配置中定义的角色ID
```
*效果：在此环节，无论玩家输入什么，都只有角色 “Suspect_A” 会进行回复。*

**场景2：校园恋爱喜剧中，玩家需要按顺序向两位朋友 Yuki 和 Roxy 解释情况**

```yaml
# ... Events ...
EndCondition:
  Type: LimitedFreeTime
  MaxTurns: 6 # 玩家说6句话，总共 Yuki 回3次，Roxy 回3次
  InstructionToPlayer: "你现在有机会向 Yuki 和 Roxy 解释一下刚才的误会。"
  NextUnitID: "after_explanation_unit"
  InteractWith:
    - "Yuki"
    - "Roxy"
```
*效果：对话将严格按照 “玩家 -> Yuki -> Roxy -> 玩家 -> Yuki -> Roxy -> ...” 的顺序进行，持续6个玩家回合。*

**场景3：不使用 `InteractWith` (传统用法)**

```yaml
# ... Events ...
EndCondition:
  Type: FreeTime
  InstructionToPlayer: "大家暂时休息一下，可以自由聊天。输入 '出发' 继续冒险。"
  ExitPromptInInputBox: "出发"
  NextUnitID: "continue_adventure_unit"
```
*效果：如果你的剧本全局配置中有 Roxy 和 Yuki 两个角色，那么对话将按照 “玩家 -> Roxy -> Yuki -> 玩家 -> Roxy -> Yuki -> ...” 的默认顺序进行。*


请创建一个简单的新剧本，用来测试这个系统是不是生效。
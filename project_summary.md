# NeoChat é¡¹ç›®æ¦‚è§ˆ

## é¡¹ç›®ç»“æ„
```text
NeoChat/
â”œâ”€â”€ characters/
â”‚   â””â”€â”€ Roxy.yaml
â”œâ”€â”€ memory-bank/
â”‚   â”œâ”€â”€ activeContext.md
â”‚   â”œâ”€â”€ productContext.md
â”‚   â”œâ”€â”€ progress.md
â”‚   â”œâ”€â”€ projectbrief.md
â”‚   â”œâ”€â”€ systemPatterns.md
â”‚   â””â”€â”€ techContext.md
â”œâ”€â”€ run_logs/
â”‚   â”œâ”€â”€ ... (1 more .log files)
â”‚   â”œâ”€â”€ AppLogger_2025-07-03_22-33-52.log
â”‚   â”œâ”€â”€ AppLogger_2025-07-03_22-36-52.log
â”‚   â””â”€â”€ AppLogger_2025-07-03_22-42-44.log
â”œâ”€â”€ saves/
â”‚   â”œâ”€â”€ save_20250703_223358/
â”‚   â”‚   â”œâ”€â”€ character/
â”‚   â”‚   â”‚   â””â”€â”€ Roxy.yaml
â”‚   â”‚   â”œâ”€â”€ save/
â”‚   â”‚   â”‚   â”œâ”€â”€ gamestate.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ å¯¹è¯è®°å½•.yaml
â”‚   â”‚   â”‚   â””â”€â”€ æ¸¸æˆè¿›åº¦.yaml
â”‚   â”‚   â”œâ”€â”€ story/
â”‚   â”‚   â”‚   â”œâ”€â”€ 00_Labyrinth_Entrance.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 01_Explore_Corridor.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 02_Event_Treasure.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03A_Player_Fights.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03B_Roxy_Fights.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03_Event_Monster.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04A_Trap_Dodged.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04B_Trap_Hit.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04_Event_Trap.yaml
â”‚   â”‚   â”‚   â””â”€â”€ 99_Exit_Labyrinth.yaml
â”‚   â”‚   â”œâ”€â”€ å…¨å±€å‰§æƒ…é…ç½®.yaml
â”‚   â”‚   â””â”€â”€ å‰§æƒ…ä»‹ç».md
â”‚   â”œâ”€â”€ save_20250703_223658/
â”‚   â”‚   â”œâ”€â”€ character/
â”‚   â”‚   â”‚   â””â”€â”€ Roxy.yaml
â”‚   â”‚   â”œâ”€â”€ save/
â”‚   â”‚   â”‚   â”œâ”€â”€ gamestate.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ å¯¹è¯è®°å½•.yaml
â”‚   â”‚   â”‚   â””â”€â”€ æ¸¸æˆè¿›åº¦.yaml
â”‚   â”‚   â”œâ”€â”€ story/
â”‚   â”‚   â”‚   â”œâ”€â”€ 00_Labyrinth_Entrance.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 01_Explore_Corridor.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 02_Event_Treasure.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03A_Player_Fights.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03B_Roxy_Fights.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03_Event_Monster.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04A_Trap_Dodged.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04B_Trap_Hit.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04_Event_Trap.yaml
â”‚   â”‚   â”‚   â””â”€â”€ 99_Exit_Labyrinth.yaml
â”‚   â”‚   â”œâ”€â”€ å…¨å±€å‰§æƒ…é…ç½®.yaml
â”‚   â”‚   â””â”€â”€ å‰§æƒ…ä»‹ç».md
â”‚   â”œâ”€â”€ save_20250703_224249/
â”‚   â”‚   â”œâ”€â”€ character/
â”‚   â”‚   â”‚   â””â”€â”€ Roxy.yaml
â”‚   â”‚   â”œâ”€â”€ save/
â”‚   â”‚   â”‚   â”œâ”€â”€ gamestate.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ å¯¹è¯è®°å½•.yaml
â”‚   â”‚   â”‚   â””â”€â”€ æ¸¸æˆè¿›åº¦.yaml
â”‚   â”‚   â”œâ”€â”€ story/
â”‚   â”‚   â”‚   â”œâ”€â”€ 00_Labyrinth_Entrance.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 01_Explore_Corridor.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 02_Event_Treasure.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03A_Player_Fights.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03B_Roxy_Fights.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 03_Event_Monster.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04A_Trap_Dodged.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04B_Trap_Hit.yaml
â”‚   â”‚   â”‚   â”œâ”€â”€ 04_Event_Trap.yaml
â”‚   â”‚   â”‚   â””â”€â”€ 99_Exit_Labyrinth.yaml
â”‚   â”‚   â”œâ”€â”€ å…¨å±€å‰§æƒ…é…ç½®.yaml
â”‚   â”‚   â””â”€â”€ å‰§æƒ…ä»‹ç».md
â”‚   â””â”€â”€ save_20250703_224652/
â”‚       â”œâ”€â”€ character/
â”‚       â”‚   â””â”€â”€ Roxy.yaml
â”‚       â”œâ”€â”€ save/
â”‚       â”‚   â”œâ”€â”€ gamestate.yaml
â”‚       â”‚   â”œâ”€â”€ å¯¹è¯è®°å½•.yaml
â”‚       â”‚   â””â”€â”€ æ¸¸æˆè¿›åº¦.yaml
â”‚       â”œâ”€â”€ story/
â”‚       â”‚   â”œâ”€â”€ 00_Labyrinth_Entrance.yaml
â”‚       â”‚   â”œâ”€â”€ 01_Explore_Corridor.yaml
â”‚       â”‚   â”œâ”€â”€ 02_Event_Treasure.yaml
â”‚       â”‚   â”œâ”€â”€ 03A_Player_Fights.yaml
â”‚       â”‚   â”œâ”€â”€ 03B_Roxy_Fights.yaml
â”‚       â”‚   â”œâ”€â”€ 03_Event_Monster.yaml
â”‚       â”‚   â”œâ”€â”€ 04A_Trap_Dodged.yaml
â”‚       â”‚   â”œâ”€â”€ 04B_Trap_Hit.yaml
â”‚       â”‚   â”œâ”€â”€ 04_Event_Trap.yaml
â”‚       â”‚   â””â”€â”€ 99_Exit_Labyrinth.yaml
â”‚       â”œâ”€â”€ å…¨å±€å‰§æƒ…é…ç½®.yaml
â”‚       â””â”€â”€ å‰§æƒ…ä»‹ç».md
â”œâ”€â”€ story_packs/
â”‚   â””â”€â”€ roxy_labyrinth_adventure/
â”‚       â”œâ”€â”€ save/
â”‚       â”‚   â””â”€â”€ gamestate.yaml
â”‚       â”œâ”€â”€ story/
â”‚       â”‚   â”œâ”€â”€ 00_Labyrinth_Entrance.yaml
â”‚       â”‚   â”œâ”€â”€ 01_Explore_Corridor.yaml
â”‚       â”‚   â”œâ”€â”€ 02_Event_Treasure.yaml
â”‚       â”‚   â”œâ”€â”€ 03A_Player_Fights.yaml
â”‚       â”‚   â”œâ”€â”€ 03B_Roxy_Fights.yaml
â”‚       â”‚   â”œâ”€â”€ 03_Event_Monster.yaml
â”‚       â”‚   â”œâ”€â”€ 04A_Trap_Dodged.yaml
â”‚       â”‚   â”œâ”€â”€ 04B_Trap_Hit.yaml
â”‚       â”‚   â”œâ”€â”€ 04_Event_Trap.yaml
â”‚       â”‚   â””â”€â”€ 99_Exit_Labyrinth.yaml
â”‚       â”œâ”€â”€ å…¨å±€å‰§æƒ…é…ç½®.yaml
â”‚       â””â”€â”€ å‰§æƒ…ä»‹ç».md
â”œâ”€â”€ .env
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ config.py
â”œâ”€â”€ game_engine.py
â”œâ”€â”€ llm_interface.py
â”œâ”€â”€ logger.py
â”œâ”€â”€ main.py
â”œâ”€â”€ start.bat
â””â”€â”€ ç”¨æ¥å¯¼å…¥å‰§æƒ…çš„.py
```

## æ–‡ä»¶å†…å®¹
### æ–‡ä»¶: `README.md`

```markdown
# NeoChat
å¯¹å®ç°AIæ°¸ä¹…è®°å¿†çš„æ¢ç´¢ã€‚

## ç®€ä»‹

A simple and pure AI conversation platform based on command-line format / è¿”ç’å½’çœŸçš„ï¼ŒåŸºäºå‘½ä»¤è¡Œå½¢å¼çš„AIå¯¹è¯å¹³å°

## ç‰¹æ€§

- ä½¿ç”¨RAGå‘é‡åº“è®°å¿†ç³»ç»Ÿï¼Œæ‹¥æœ‰æ•°ä¸‡æ¡ä¸Šä¸‹æ–‡çš„è®°å¿†ï¼Œä¸”ä¸ä¼šè€—è´¹å¤ªå¤šTokenã€‚

## ç”¨æ³•

- ä¾ç…§requirementsåˆ›å»º.venvè™šæ‹Ÿç¯å¢ƒ
- æ‰“å¼€.env.exampleï¼Œä¿®æ”¹ç³»ç»Ÿæç¤ºè¯å’Œä½ çš„apikeyï¼Œå¹¶é‡å‘½åä¸º.env
- å¯¹è¯å†å²å‚¨å­˜åœ¨Dialogue_historyä¸­ã€‚
- chroma_db_storeæ˜¯RAGç”Ÿæˆçš„å†å²å¯¹è¯å‘é‡åº“ï¼Œåˆ é™¤åå¯è‡ªåŠ¨åˆ›å»ºã€‚

## æ›´æ–°

- **é•¿çº¿å‰§æƒ…ç³»ç»Ÿ**ï¼šæ”¯æŒä½¿ç”¨ç±»ä¼¼galgameçš„å‰§æƒ…é¢„è®¾ï¼Œç›´æ¥å…¼å®¹ä¼ ç»Ÿgalgameçš„é¢„è®¾å‰§æœ¬å’Œåˆ†æ­§é€‰æ‹©ï¼ŒåŒæ—¶æ”¯æŒå°†ä¸€éƒ¨åˆ†ç”šè‡³å…¨éƒ¨çš„å‰§æƒ…**ç”±AIé©±åŠ¨**ã€‚ä½ å°†åœ¨å‰§æƒ…å†…æ—¥å¸¸çš„åœºåˆï¼Œåœä¸‹æ¥å’Œä¸»è§’è‡ªç”±çš„è°ˆå¿ƒï¼ŒèŠå¤Ÿäº†åœ¨ç»§ç»­å‰§æƒ…ï¼›ä½ å°†ä¸å†å±€é™äºç‚¹å‡»é€‰é¡¹æ¥é€‰æ‹©å‰§æƒ…åˆ†æ­§ï¼Œè€Œæ˜¯çœŸæ­£è¿›å…¥æ•…äº‹ï¼Œè¯´å‡ºä½ æƒ³è¯´çš„è¯ï¼Œå½±å“ä¸»è§’åšå‡ºé‡è¦é€‰æ‹©ï¼Œæˆ–è€…**åŠè¯´**ä¸»è§’çœŸæ­£çš„å›å¿ƒè½¬æ„ã€‚
- **å‰§æœ¬æ€/è·‘å›¢æ¨¡å¼**ï¼šæ”¯æŒä½¿ç”¨ç±»ä¼¼å‰§æœ¬æ€/è·‘å›¢æ¨¡å¼çš„å‰§æƒ…é¢„è®¾ï¼Œç”±ä¸€ä¸ªDMï¼ˆä¸»æŒäººï¼‰æ¥æŒæ§å‰§æƒ…çš„å‘å±•ï¼Œä½ å°†ä½“éªŒåˆ°è¯¸å¦‚éšç€æ—¶é—´çš„æ¨ç§»è·å¾—è¶Šæ¥è¶Šå¤šçš„ä¿¡æ¯ï¼Œåˆ¤æ–­â€œè°æ˜¯å‡¶æ‰‹â€ï¼Œç­‰ç±»å‰§æƒ…æ¸¸æˆ
- **éšæœºäº‹ä»¶ç”Ÿæˆå™¨**ï¼šè½»é‡åŒ–çš„å‰§æƒ…å¼•å¯¼ï¼Œå¦‚ä½ å’Œä½ çš„ocæ¢ç´¢åœ°ä¸‹è¿·å®«çš„è¿‡ç¨‹ä¸­ï¼Œç”±LLMç”Ÿæˆä½ ä»¬ä¸‹ä¸€ä¸ªæˆ¿é—´çš„è§é—»
- **å¤§é‡çš„é¢„è®¾å°æ¸¸æˆ**ï¼šå’Œä½ çš„ä¸€ä¸ªç”šè‡³å¤šä¸ªocäººè®¾ç©ä¸€æŠŠç‹¼äººæ€ï¼ŒçœŸå¿ƒè¯å¤§å†’é™©ï¼Œç”šè‡³æ¶é­”è½®ç›˜èµŒç­‰ç»å…¸äº’åŠ¨æ¸¸æˆ
```

### æ–‡ä»¶: `readme.md`

```markdown
# NeoChat
å¯¹å®ç°AIæ°¸ä¹…è®°å¿†çš„æ¢ç´¢ã€‚

## ç®€ä»‹

A simple and pure AI conversation platform based on command-line format / è¿”ç’å½’çœŸçš„ï¼ŒåŸºäºå‘½ä»¤è¡Œå½¢å¼çš„AIå¯¹è¯å¹³å°

## ç‰¹æ€§

- ä½¿ç”¨RAGå‘é‡åº“è®°å¿†ç³»ç»Ÿï¼Œæ‹¥æœ‰æ•°ä¸‡æ¡ä¸Šä¸‹æ–‡çš„è®°å¿†ï¼Œä¸”ä¸ä¼šè€—è´¹å¤ªå¤šTokenã€‚

## ç”¨æ³•

- ä¾ç…§requirementsåˆ›å»º.venvè™šæ‹Ÿç¯å¢ƒ
- æ‰“å¼€.env.exampleï¼Œä¿®æ”¹ç³»ç»Ÿæç¤ºè¯å’Œä½ çš„apikeyï¼Œå¹¶é‡å‘½åä¸º.env
- å¯¹è¯å†å²å‚¨å­˜åœ¨Dialogue_historyä¸­ã€‚
- chroma_db_storeæ˜¯RAGç”Ÿæˆçš„å†å²å¯¹è¯å‘é‡åº“ï¼Œåˆ é™¤åå¯è‡ªåŠ¨åˆ›å»ºã€‚

## æ›´æ–°

- **é•¿çº¿å‰§æƒ…ç³»ç»Ÿ**ï¼šæ”¯æŒä½¿ç”¨ç±»ä¼¼galgameçš„å‰§æƒ…é¢„è®¾ï¼Œç›´æ¥å…¼å®¹ä¼ ç»Ÿgalgameçš„é¢„è®¾å‰§æœ¬å’Œåˆ†æ­§é€‰æ‹©ï¼ŒåŒæ—¶æ”¯æŒå°†ä¸€éƒ¨åˆ†ç”šè‡³å…¨éƒ¨çš„å‰§æƒ…**ç”±AIé©±åŠ¨**ã€‚ä½ å°†åœ¨å‰§æƒ…å†…æ—¥å¸¸çš„åœºåˆï¼Œåœä¸‹æ¥å’Œä¸»è§’è‡ªç”±çš„è°ˆå¿ƒï¼ŒèŠå¤Ÿäº†åœ¨ç»§ç»­å‰§æƒ…ï¼›ä½ å°†ä¸å†å±€é™äºç‚¹å‡»é€‰é¡¹æ¥é€‰æ‹©å‰§æƒ…åˆ†æ­§ï¼Œè€Œæ˜¯çœŸæ­£è¿›å…¥æ•…äº‹ï¼Œè¯´å‡ºä½ æƒ³è¯´çš„è¯ï¼Œå½±å“ä¸»è§’åšå‡ºé‡è¦é€‰æ‹©ï¼Œæˆ–è€…**åŠè¯´**ä¸»è§’çœŸæ­£çš„å›å¿ƒè½¬æ„ã€‚
- **å‰§æœ¬æ€/è·‘å›¢æ¨¡å¼**ï¼šæ”¯æŒä½¿ç”¨ç±»ä¼¼å‰§æœ¬æ€/è·‘å›¢æ¨¡å¼çš„å‰§æƒ…é¢„è®¾ï¼Œç”±ä¸€ä¸ªDMï¼ˆä¸»æŒäººï¼‰æ¥æŒæ§å‰§æƒ…çš„å‘å±•ï¼Œä½ å°†ä½“éªŒåˆ°è¯¸å¦‚éšç€æ—¶é—´çš„æ¨ç§»è·å¾—è¶Šæ¥è¶Šå¤šçš„ä¿¡æ¯ï¼Œåˆ¤æ–­â€œè°æ˜¯å‡¶æ‰‹â€ï¼Œç­‰ç±»å‰§æƒ…æ¸¸æˆ
- **éšæœºäº‹ä»¶ç”Ÿæˆå™¨**ï¼šè½»é‡åŒ–çš„å‰§æƒ…å¼•å¯¼ï¼Œå¦‚ä½ å’Œä½ çš„ocæ¢ç´¢åœ°ä¸‹è¿·å®«çš„è¿‡ç¨‹ä¸­ï¼Œç”±LLMç”Ÿæˆä½ ä»¬ä¸‹ä¸€ä¸ªæˆ¿é—´çš„è§é—»
- **å¤§é‡çš„é¢„è®¾å°æ¸¸æˆ**ï¼šå’Œä½ çš„ä¸€ä¸ªç”šè‡³å¤šä¸ªocäººè®¾ç©ä¸€æŠŠç‹¼äººæ€ï¼ŒçœŸå¿ƒè¯å¤§å†’é™©ï¼Œç”šè‡³æ¶é­”è½®ç›˜èµŒç­‰ç»å…¸äº’åŠ¨æ¸¸æˆ
```

### æ–‡ä»¶: `config.py`

```python
import os
from dotenv import load_dotenv
load_dotenv()
# config.py

# --- å¿…å¡«é¡¹ ---
# åœ¨è¿™é‡Œå¡«å…¥ä½ çš„DeepSeek API Key
API_KEY = os.getenv("API_KEY")

# --- æ¨¡å‹é…ç½® ---
# ä½¿ç”¨çš„æ¨¡å‹åç§°ï¼Œä¾‹å¦‚ 'deepseek-chat' æˆ– 'deepseek-coder'
MODEL_NAME = "deepseek-chat"
API_URL = "https://api.deepseek.com/chat/completions"
MAX_TOKENS = 2048
TEMPERATURE = 0.7
API_TIMEOUT_SECONDS = 120

# --- åº”ç”¨é…ç½® ---
# DEBUGæ¨¡å¼ä¼šè¾“å‡ºæµ·é‡çš„ç°è‰²æ—¥å¿—ï¼Œç”¨äºè°ƒè¯•
DEBUG_MODE = False
AI_NAME = "NeoChat"

# --- å­˜æ¡£ä¸å‰§æœ¬è·¯å¾„ ---
# å‰§æœ¬åŒ…å­˜æ”¾çš„æ ¹ç›®å½•
STORY_PACKS_BASE_PATH = "./story_packs"
# è§’è‰²äººè®¾å­˜æ”¾çš„æ ¹ç›®å½•
CHARACTERS_BASE_PATH = "./characters"
# æ¸¸æˆå­˜æ¡£å­˜æ”¾çš„æ ¹ç›®å½•
SAVES_BASE_PATH = "./saves"
```

### æ–‡ä»¶: `game_engine.py`

```python
# game_engine.py
import os
import shutil
import yaml
import re
import random
import uuid
from datetime import datetime

import config
from logger import log_debug, log_info, log_warning, log_error, log_info_color, TermColors
from llm_interface import chat_with_deepseek

class GameEngine:
    def __init__(self):
        self.save_path = None
        self.story_pack_path = None
        self.character_files = {} # role_id -> character_data
        
        # In-memory state
        self.game_state = {}
        self.progress = {}
        self.dialogue_history = []
        self.global_config = {}
        self.current_story_unit = None
        # --- æ–°å¢: è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ï¼Œç”¨äºå­˜æ”¾ä¸éœ€å­˜æ¡£çš„ä¸´æ—¶å˜é‡ ---
        self.runtime_context = {}

        self.is_running = False
        self.game_over = False

    def _format_string(self, text):
        """ç”¨ game_state å’Œ runtime_context ä¸­çš„å˜é‡æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„ {placeholder}"""
        if not isinstance(text, str):
            return text
        
        # æ­£åˆ™è¡¨è¾¾å¼å¯»æ‰¾ {variable_name}
        placeholders = re.findall(r'\{([a-zA-Z0-9_]+)\}', text)
        
        formatted_text = text
        for placeholder in placeholders:
            value = None
            # --- æ ¸å¿ƒä¿®æ”¹ï¼šä¼˜å…ˆä»è¿è¡Œæ—¶ä¸Šä¸‹æ–‡æŸ¥æ‰¾ ---
            if placeholder in self.runtime_context:
                value = self.runtime_context[placeholder]
            # --- å…¶æ¬¡ä»æ¸¸æˆçŠ¶æ€æŸ¥æ‰¾ ---
            elif placeholder in self.game_state:
                value = self.game_state[placeholder]
            else:
                log_warning(f"æ ¼å¼åŒ–å­—ç¬¦ä¸²æ—¶æœªåœ¨ game_state æˆ– runtime_context ä¸­æ‰¾åˆ°å˜é‡: {placeholder}")
                continue # å¦‚æœæ‰¾ä¸åˆ°ï¼Œè·³è¿‡æ›¿æ¢

            # ç¡®ä¿æ›¿æ¢å€¼çš„ç±»å‹æ­£ç¡®
            if value is not None:
                formatted_text = formatted_text.replace(f'{{{placeholder}}}', str(value))

        return formatted_text

    def _evaluate_condition(self, condition_str):
        """å®‰å…¨åœ°è¯„ä¼°æ¡ä»¶è¡¨è¾¾å¼"""
        formatted_condition = self._format_string(condition_str)
        log_debug(f"æ­£åœ¨è¯„ä¼°æ¡ä»¶: `{condition_str}` -> `{formatted_condition}`")
        try:
            # ä¸ºå®‰å…¨èµ·è§ï¼Œåªå…è®¸ç®€å•çš„æ¯”è¾ƒå’Œé€»è¾‘è¿ç®—
            # æ›´å®‰å…¨çš„åšæ³•æ˜¯ä½¿ç”¨ast.literal_evalæˆ–ä¸€ä¸ªä¸“é—¨çš„è¡¨è¾¾å¼æ±‚å€¼åº“
            result = eval(formatted_condition, {"__builtins__": {}}, {})
            log_debug(f"æ¡ä»¶è¯„ä¼°ç»“æœ: {result}")
            return result
        except Exception as e:
            log_error(f"è¯„ä¼°æ¡ä»¶æ—¶å‡ºé”™: '{formatted_condition}'. é”™è¯¯: {e}")
            return False

    def _add_to_dialogue_history(self, event_type, **kwargs):
        log_entry = {
            "id": f"evt_{uuid.uuid4()}",
            "timestamp": datetime.now().isoformat(),
            "source_unit_id": self.progress.get('progress_pointer', {}).get('current_unit_id'),
            "source_event_index": self.progress.get('progress_pointer', {}).get('last_completed_event_index'),
            "type": event_type
        }

        # æ ¸å¿ƒä¿®æ”¹é€»è¾‘ï¼šæ ¹æ®kwargsçš„ç»“æ„å†³å®šæ•°æ®æ ¼å¼
        # å¦‚æœkwargsåªæœ‰ä¸€ä¸ª'content'é”®ï¼Œåˆ™å°†å…¶æå‡åˆ°é¡¶å±‚
        if len(kwargs) == 1 and 'content' in kwargs:
            log_entry['content'] = kwargs['content']
        # å¦åˆ™ï¼Œå°†æ‰€æœ‰kwargsä½œä¸ºç»“æ„åŒ–æ•°æ®æ”¾å…¥'data'å­—æ®µ
        else:
            log_entry['data'] = kwargs

        self.dialogue_history.append(log_entry)
        log_debug(f"æ·»åŠ æ–°å¯¹è¯è®°å½•: {log_entry}")

    def load_story_pack(self, story_pack_path, character_selections):
        """å¼€å§‹ä¸€ä¸ªæ–°æ¸¸æˆ"""
        try:
            # 1. åˆ›å»ºå­˜æ¡£æ–‡ä»¶å¤¹
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.save_path = os.path.join(config.SAVES_BASE_PATH, f"save_{timestamp}")
            os.makedirs(os.path.join(self.save_path, "save"), exist_ok=True)
            
            # 2. å¤åˆ¶å‰§æœ¬å’Œè§’è‰²æ–‡ä»¶
            shutil.copytree(story_pack_path, self.save_path, dirs_exist_ok=True)
            char_dir_in_save = os.path.join(self.save_path, "character")
            os.makedirs(char_dir_in_save, exist_ok=True)
            for role_id, char_path in character_selections.items():
                shutil.copy(char_path, os.path.join(char_dir_in_save, f"{role_id}.yaml"))

            self.story_pack_path = self.save_path
            
            # 3. åŠ è½½å…¨å±€é…ç½®å’Œè§’è‰²
            with open(os.path.join(self.story_pack_path, 'å…¨å±€å‰§æƒ…é…ç½®.yaml'), 'r', encoding='utf-8') as f:
                self.global_config = yaml.safe_load(f)
            
            self._load_character_files()

            # 4. åˆå§‹åŒ– gamestate.yaml
            with open(os.path.join(self.story_pack_path, 'save', 'gamestate.yaml'), 'r', encoding='utf-8') as f:
                self.game_state = yaml.safe_load(f) or {}

            # 5. åˆå§‹åŒ– æ¸¸æˆè¿›åº¦.yaml
            self.progress = {
                "save_name": "New Game",
                "story_pack_id": self.global_config.get('id', 'unknown'),
                "last_saved_timestamp": datetime.now().isoformat(),
                "progress_pointer": {
                    "current_unit_id": self.global_config['start_unit_id'],
                    "last_completed_event_index": -1
                },
                "runtime_state": "ExecutingEvents"
            }

            # 6. åˆå§‹åŒ– å¯¹è¯è®°å½•.yaml
            self.dialogue_history = []
            
            self.is_running = True
            log_info(f"æ–°æ¸¸æˆå·²åˆ›å»ºï¼Œå­˜æ¡£ä½äº: {self.save_path}")
            
            # è¿›è¡Œä¸€æ¬¡åˆå§‹ä¿å­˜ï¼Œç¡®ä¿æ‰€æœ‰çŠ¶æ€æ–‡ä»¶éƒ½å·²åˆ›å»º
            self.save_game("åˆå§‹å­˜æ¡£") 
            
            return True
        except Exception as e:
            log_error(f"åˆ›å»ºæ–°æ¸¸æˆå¤±è´¥: {e}")
            return False

    def _load_character_files(self):
        char_dir = os.path.join(self.story_pack_path, "character")
        self.character_files = {}
        for filename in os.listdir(char_dir):
            if filename.endswith(".yaml"):
                role_id = filename.split('.')[0]
                with open(os.path.join(char_dir, filename), 'r', encoding='utf-8') as f:
                    self.character_files[role_id] = yaml.safe_load(f)
                # å°†è§’è‰²åæ³¨å…¥gamestate
                self.game_state[f'character_name_{role_id}'] = self.character_files[role_id]['name']

    def load_from_save(self, save_path):
        """ä»å­˜æ¡£åŠ è½½æ¸¸æˆ"""
        try:
            self.save_path = save_path
            self.story_pack_path = save_path
            
            with open(os.path.join(self.save_path, 'save', 'gamestate.yaml'), 'r', encoding='utf-8') as f:
                self.game_state = yaml.safe_load(f)
            with open(os.path.join(self.save_path, 'save', 'æ¸¸æˆè¿›åº¦.yaml'), 'r', encoding='utf-8') as f:
                self.progress = yaml.safe_load(f)
            with open(os.path.join(self.save_path, 'save', 'å¯¹è¯è®°å½•.yaml'), 'r', encoding='utf-8') as f:
                self.dialogue_history = yaml.safe_load(f)
            with open(os.path.join(self.story_pack_path, 'å…¨å±€å‰§æƒ…é…ç½®.yaml'), 'r', encoding='utf-8') as f:
                self.global_config = yaml.safe_load(f)

            self._load_character_files()

            self.is_running = True
            log_info(f"æˆåŠŸä» {save_path} åŠ è½½å­˜æ¡£ã€‚")
            return True
        except Exception as e:
            log_error(f"åŠ è½½å­˜æ¡£å¤±è´¥: {e}")
            return False

    def save_game(self, save_name=None):
        if not self.is_running:
            log_warning("æ¸¸æˆæœªè¿è¡Œï¼Œæ— æ³•ä¿å­˜ã€‚")
            return
        
        try:
            if save_name:
                self.progress['save_name'] = save_name
            self.progress['last_saved_timestamp'] = datetime.now().isoformat()
            
            save_dir = os.path.join(self.save_path, 'save')
            with open(os.path.join(save_dir, 'gamestate.yaml'), 'w', encoding='utf-8') as f:
                yaml.dump(self.game_state, f, allow_unicode=True)
            with open(os.path.join(save_dir, 'æ¸¸æˆè¿›åº¦.yaml'), 'w', encoding='utf-8') as f:
                yaml.dump(self.progress, f, allow_unicode=True)
            with open(os.path.join(save_dir, 'å¯¹è¯è®°å½•.yaml'), 'w', encoding='utf-8') as f:
                yaml.dump(self.dialogue_history, f, allow_unicode=True)
            
            log_info_color(f"æ¸¸æˆå·²ä¿å­˜ï¼Œå­˜æ¡£å: '{self.progress['save_name']}'", TermColors.GREEN)
        except Exception as e:
            log_error(f"ä¿å­˜æ¸¸æˆå¤±è´¥: {e}")

    def run(self):
        """ä¸»æ¸¸æˆå¾ªç¯ï¼Œæ‰§è¡Œäº‹ä»¶ç›´åˆ°éœ€è¦ç©å®¶è¾“å…¥"""
        if not self.is_running or self.game_over:
            return

        while self.progress['runtime_state'] == 'ExecutingEvents' and not self.game_over:
            pointer = self.progress['progress_pointer']
            unit_id = pointer['current_unit_id']
            
            # åŠ è½½å½“å‰å‰§æƒ…å•å…ƒ
            unit_path = os.path.join(self.story_pack_path, 'story', f"{unit_id}.yaml")
            if not os.path.exists(unit_path):
                log_error(f"å‰§æƒ…å•å…ƒæ–‡ä»¶æœªæ‰¾åˆ°: {unit_path}")
                self.game_over = True
                break
            with open(unit_path, 'r', encoding='utf-8') as f:
                self.current_story_unit = yaml.safe_load(f)

            next_event_index = pointer['last_completed_event_index'] + 1
            events = self.current_story_unit.get('Events', [])
            
            if next_event_index >= len(events):
                # äº‹ä»¶æ‰§è¡Œå®Œæ¯•ï¼Œå¤„ç†EndCondition
                self._process_end_condition(self.current_story_unit.get('EndCondition'))
            else:
                # æ‰§è¡Œä¸‹ä¸€ä¸ªäº‹ä»¶
                self._process_event(events[next_event_index])
                if self.progress['runtime_state'] == 'ExecutingEvents': # ç¡®ä¿äº‹ä»¶æ²¡æœ‰æ”¹å˜çŠ¶æ€
                     pointer['last_completed_event_index'] = next_event_index
        
        log_debug(f"å¼•æ“æš‚åœï¼Œå½“å‰çŠ¶æ€: {self.progress['runtime_state']}")


    def _process_event(self, event_data):
        log_debug(f"å¤„ç†äº‹ä»¶: {event_data}")

        # å¤„ç†æ¡ä»¶
        if 'Condition' in event_data:
            if not self._evaluate_condition(event_data['Condition']):
                log_debug("æ¡ä»¶ä¸æ»¡è¶³ï¼Œè·³è¿‡è¯¥äº‹ä»¶å—ã€‚")
                # å³ä½¿è·³è¿‡ï¼Œä¹Ÿç®—å®Œæˆè¿™ä¸ª"æ¡ä»¶äº‹ä»¶"
                self.progress['progress_pointer']['last_completed_event_index'] += 1
                return
            # å¦‚æœæ¡ä»¶æ»¡è¶³ï¼Œæ‰§è¡ŒåµŒå¥—çš„Events
            for nested_event in event_data['Events']:
                 self._process_event(nested_event)
            # å®Œæˆåï¼Œæ›´æ–°ä¸»äº‹ä»¶ç´¢å¼•
            self.progress['progress_pointer']['last_completed_event_index'] += 1
            return

        event_key, event_content = list(event_data.items())[0]
        params = dict(param.strip().split(': ') for param in event_key.split(' | '))
        event_type = params['Type']
        
        # æ ¼å¼åŒ–å†…å®¹
        if isinstance(event_content, str):
            content = self._format_string(event_content)
        elif isinstance(event_content, dict):
            content = {k: self._format_string(v) for k, v in event_content.items()}
        else:
            content = event_content

        if event_type == 'Narration':
            if params.get('Mode') == 'Prompt':
                log_debug("ç”Ÿæˆ 'Narration' prompt...")
                # æ—ç™½/DMçš„é€šç”¨ç³»ç»Ÿæç¤º
                narrator_prompt = "ä½ æ˜¯ä¸€ä¸ªä¼˜ç§€çš„ã€æ²‰æµ¸å¼çš„æ•…äº‹è®²è¿°è€…ï¼ˆæ—ç™½ï¼‰ã€‚è¯·æ ¹æ®ä»¥ä¸‹è¦æ±‚å’Œå¯¹è¯å†å²ï¼Œç”Ÿæˆä¸€æ®µå¯Œæœ‰æ–‡é‡‡çš„æ—ç™½ã€‚ç›´æ¥è¾“å‡ºæ—ç™½å†…å®¹ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€‚"
                messages = [
                    {"role": "system", "content": narrator_prompt},
                    {"role": "user", "content": f"è¿™æ˜¯ä½ çš„ç”Ÿæˆè¦æ±‚ï¼š\n{content}"}
                ]
                # å¯ä»¥é€‰æ‹©æ€§åœ°åŠ å…¥æœ€è¿‘çš„å¯¹è¯å†å²
                for record in self.dialogue_history[-5:]:
                    # ä»è®°å½•ä¸­è·å–çº¯æ–‡æœ¬å†…å®¹
                    content = record.get('content') or record.get('data', {}).get('content')
                    if not content:
                        continue

                    if record['type'] == 'Dialogue':
                        hist_char_id = record.get('data', {}).get('character_id')
                        if hist_char_id:
                            # å¯¹äºæ—ç™½ç”Ÿæˆï¼Œæ‰€æœ‰å†å²å¯¹è¯éƒ½ä½œä¸ºç”¨æˆ·è¾“å…¥
                            messages.insert(-1, {"role": "user", "content": content})
                    elif record['type'] == 'Player':
                        # ç©å®¶å‘è¨€ä¹Ÿä½œä¸ºç”¨æˆ·è¾“å…¥
                        messages.insert(-1, {"role": "user", "content": content})
                
                # --- æ ¸å¿ƒä¿®æ”¹ç‚¹ ---
                # chat_with_deepseek å†…éƒ¨å·²ç»å¤„ç†äº†æµå¼æ‰“å°
                # å®ƒè¿”å›çš„ generated_content ä»…ç”¨äºä¿å­˜å†å²è®°å½•
                generated_content = chat_with_deepseek(messages, character_name="æ—ç™½", color_code=TermColors.GREY)
                
                if generated_content:
                    # æ³¨æ„ï¼šè¿™é‡Œä¸å†æ‰§è¡Œ print()
                    self._add_to_dialogue_history('Narration', content=generated_content)
                else:
                    log_error("æ—ç™½ç”Ÿæˆå¤±è´¥ã€‚")
                    self.game_over = True
                    return
            else: # è¿™æ˜¯å¤„ç† Mode: Preset çš„æƒ…å†µ
                print(f"{TermColors.GREY}æ—ç™½: {content}{TermColors.RESET}")
                self._add_to_dialogue_history('Narration', content=content)
        
        elif event_type == 'Dialogue':
            char_id = self._format_string(params['Character'])
            char_name = self.character_files.get(char_id, {}).get('name', char_id)
            
            if params['Mode'] == 'Preset':
                print(f"{TermColors.CYAN}{char_name}:{TermColors.RESET} {content}")
                self._add_to_dialogue_history('Dialogue', character_id=char_id, content=content)
            
            elif params['Mode'] == 'Prompt':
                # æ„å»ºLLMè¯·æ±‚
                messages = []
                # 1. æ·»åŠ è§’è‰²è®¾å®š
                # --- ä¿®å¤ç‚¹ï¼šæ ¼å¼åŒ–è§’è‰²promptä¸­çš„æ¨¡æ¿å˜é‡ ---
                character_prompt = self._format_string(self.character_files[char_id]['prompt'])
                messages.append({"role": "system", "content": character_prompt})
                # 2. æ·»åŠ å¯¹è¯å†å²
                for record in self.dialogue_history[-10:]: # å–æœ€è¿‘10æ¡
                    # ä»è®°å½•ä¸­è·å–çº¯æ–‡æœ¬å†…å®¹
                    content = record.get('content') or record.get('data', {}).get('content')
                    if not content:
                        continue

                    if record['type'] == 'Dialogue':
                        hist_char_id = record.get('data', {}).get('character_id')
                        if hist_char_id:
                            # æ ¹æ®å½“å‰è¦ç”Ÿæˆå¯¹è¯çš„è§’è‰²ID (char_id) æ¥å†³å®šå†å²è®°å½•ä¸­çš„è§’è‰²æ˜¯ 'assistant' è¿˜æ˜¯ 'user'
                            role = "assistant" if hist_char_id == char_id else "user"
                            messages.append({"role": role, "content": content}) # ä¿®æ­£: åªå‘é€çº¯æ–‡æœ¬å†…å®¹
                    
                    elif record['type'] == 'Player':
                        # ç©å®¶çš„å‘è¨€å¯¹ä»»ä½•AIè§’è‰²æ¥è¯´éƒ½æ˜¯ 'user'
                        messages.append({"role": "user", "content": content}) # ä¿®æ­£: åªå‘é€çº¯æ–‡æœ¬å†…å®¹

                # 3. æ·»åŠ å½“å‰Prompt
                messages.append({"role": "system", "content": f"è¿™æ˜¯ä½ çš„å†…å¿ƒç‹¬ç™½æˆ–è¡Œä¸ºæŒ‡å¼•ï¼Œè¯·æ ¹æ®å®ƒç”Ÿæˆä¸€å¥å¯¹è¯ã€‚ä¸è¦æŠŠå†…å¿ƒç‹¬ç™½æœ¬èº«è¯´å‡ºæ¥ã€‚\nå†…å¿ƒç‹¬ç™½: {content}"})
                
                # --- æ ¸å¿ƒä¿®æ”¹ç‚¹ ---
                # chat_with_deepseek å†…éƒ¨å·²ç»å¤„ç†äº†æµå¼æ‰“å°
                # å®ƒè¿”å›çš„ response ä»…ç”¨äºä¿å­˜å†å²è®°å½•
                response = chat_with_deepseek(messages, char_name, color_code=TermColors.CYAN)

                if response:
                    # æ³¨æ„ï¼šç§»é™¤äº†è¿™é‡Œçš„ print() è¯­å¥
                    self._add_to_dialogue_history('Dialogue', character_id=char_id, content=response)
                else:
                    log_error("LLMæœªèƒ½ç”Ÿæˆå“åº”ï¼Œæ¸¸æˆå¯èƒ½æ— æ³•ç»§ç»­ã€‚")
                    self.game_over = True
        
        elif event_type == 'Player':
            if params['Mode'] == 'Input':
                self.progress['runtime_state'] = 'WaitingForPlayerInput'
                if content: # æœ‰é»˜è®¤æç¤º
                    print(f"{TermColors.YELLOW}ä½  (å¯è¾“å…¥æˆ–ç›´æ¥å›è½¦ä½¿ç”¨é»˜è®¤): {content}{TermColors.RESET}")
                else:
                    print(f"{TermColors.YELLOW}ä½ :{TermColors.RESET} ", end="")
            elif params['Mode'] == 'Preset':
                print(f"{TermColors.YELLOW}ä½ :{TermColors.RESET} {content}")
                self._add_to_dialogue_history('Player', content=content)
        
        elif event_type == 'Notice':
            # æ£€æŸ¥æ˜¯å¦ä¸º Prompt æ¨¡å¼
            if params.get('Mode') == 'Prompt':
                log_debug("ç”Ÿæˆ 'Notice' prompt...")
                # å…¬å‘Šé€šå¸¸ç”±DMå‘å‡ºï¼Œæ‰€ä»¥ä½¿ç”¨DMçš„äººè®¾
                dm_char_id = self.global_config.get('dm_role_id', 'DM')  # å‡è®¾å…¨å±€é…ç½®ä¸­æœ‰DMè§’è‰²ID
                dm_char = self.character_files.get(dm_char_id)
                # --- ä¿®å¤ç‚¹ï¼šæ ¼å¼åŒ–DMè§’è‰²promptä¸­çš„æ¨¡æ¿å˜é‡ ---
                if dm_char:
                    dm_prompt = self._format_string(dm_char['prompt'])
                else:
                    dm_prompt = "ä½ æ˜¯ä¸€ä¸ªå‰§æœ¬æ€çš„DMï¼ˆä¸»æŒäººï¼‰ã€‚"
                
                messages = [
                    {"role": "system", "content": dm_prompt},
                    {"role": "user", "content": f"è¿™æ˜¯ä½ çš„ç”Ÿæˆè¦æ±‚ï¼š\n{content}"}
                ]
                # å¯ä»¥åŠ å…¥å¯¹è¯å†å²
                for record in self.dialogue_history[-5:]:
                    # ä»è®°å½•ä¸­è·å–çº¯æ–‡æœ¬å†…å®¹
                    content = record.get('content') or record.get('data', {}).get('content')
                    if not content:
                        continue

                    if record['type'] == 'Dialogue':
                        hist_char_id = record.get('data', {}).get('character_id')
                        if hist_char_id:
                            # å¯¹äºå…¬å‘Šç”Ÿæˆï¼Œæ‰€æœ‰å†å²å¯¹è¯éƒ½ä½œä¸ºç”¨æˆ·è¾“å…¥
                            messages.insert(-1, {"role": "user", "content": content})
                    elif record['type'] == 'Player':
                        # ç©å®¶å‘è¨€ä¹Ÿä½œä¸ºç”¨æˆ·è¾“å…¥
                        messages.insert(-1, {"role": "user", "content": content})
                
                generated_content = chat_with_deepseek(messages, character_name=dm_char.get('name', 'DM') if dm_char else 'DM', color_code=TermColors.MAGENTA)
                if generated_content:
                    content = generated_content
                else:
                    log_error("å…¬å‘Šç”Ÿæˆå¤±è´¥ã€‚")
                    self.game_over = True
                    return

            location = params.get('Location', 'popup')
            print(f"\n{TermColors.MAGENTA}--- [{location.upper()}] å…¬å‘Š ---\n{content}\n--------------------{TermColors.RESET}")
            self._add_to_dialogue_history('Notice', location=location, content=content)
        
        elif event_type == 'Chapter':
            print(f"\n{TermColors.GREEN}===== {content['Title']} ====={TermColors.RESET}")
            print(f"{TermColors.GREY}{content['Description']}{TermColors.RESET}\n")
            self._add_to_dialogue_history('Chapter', **content)

        elif event_type == 'Action':
            tool = params['Tool']
            var_name = params['Variable']
            if tool == 'Set':
                self.game_state[var_name] = content['Value']
            elif tool == 'Calculate':
                expr = self._format_string(content['Expression'])
                self.game_state[var_name] = eval(expr, {}, self.game_state)
            elif tool == 'Random':
                self.game_state[var_name] = random.randint(content['Min'], content['Max'])
            elif tool == 'RandomChoice':
                choices = content['Choices']
                self.game_state[var_name] = random.choice(choices)
            log_debug(f"Actionæ‰§è¡Œå®Œæ¯•, {var_name} = {self.game_state.get(var_name)}")


    def _process_end_condition(self, end_data):
        if not end_data:
            log_info("å‰§æƒ…å•å…ƒç»“æŸï¼Œæ— EndConditionï¼Œæ¸¸æˆç»“æŸã€‚")
            self.game_over = True
            return

        end_type = end_data['Type']
        log_debug(f"å¤„ç†EndCondition: {end_type}")

        if end_type == 'Linear':
            self._transition_to_unit(end_data['NextUnitID'])
        
        elif end_type == 'FreeTime' or end_type == 'LimitedFreeTime':
            self.progress['runtime_state'] = 'InFreeTime'
            self.progress['free_time_context'] = {
                'end_condition': end_data,
                'turns_taken': 0
            }
            log_info_color(self._format_string(end_data['InstructionToPlayer']), TermColors.BLUE)
        
        elif end_type == 'Branching':
            if end_data['Method'] == 'PlayerChoice':
                self.progress['runtime_state'] = 'WaitingForPlayerChoice'
                self.progress['choice_context'] = end_data
                print(f"{TermColors.YELLOW}è¯·åšå‡ºä½ çš„é€‰æ‹©ï¼š{TermColors.RESET}")
                for key, branch in end_data['Branches'].items():
                    print(f"  [{key}] {self._format_string(branch['DisplayText'])}")
            
            elif end_data['Method'] == 'AIChoice':
                log_info_color("AI æ­£åœ¨åšå‡ºå†³å®š...", TermColors.BLUE)
                self.progress['runtime_state'] = 'ProcessingAIChoice'
                self.progress['ai_choice_context'] = end_data
                self._execute_ai_choice()  # ç›´æ¥è°ƒç”¨å¤„ç†å‡½æ•°

        elif end_type == 'Conditional':
            found_match = False
            for case in end_data['Cases']:
                if self._evaluate_condition(case['Condition']):
                    # é€’å½’å¤„ç† 'Then' ä¸­çš„EndCondition
                    self._process_end_condition(case['Then'])
                    found_match = True
                    break
            if not found_match and 'Else' in end_data:
                self._process_end_condition(end_data['Else'])
        
        else:
            log_error(f"æœªçŸ¥çš„EndConditionç±»å‹: {end_type}")
            self.game_over = True

    def _transition_to_unit(self, unit_id):
        log_debug(f"åˆ‡æ¢å‰§æƒ…å•å…ƒåˆ°: {unit_id}")
        self.progress['progress_pointer']['current_unit_id'] = unit_id
        self.progress['progress_pointer']['last_completed_event_index'] = -1
        self.progress['runtime_state'] = 'ExecutingEvents'

    def provide_player_input(self, text):
        state = self.progress['runtime_state']
        if state == 'WaitingForPlayerInput':
            pointer = self.progress['progress_pointer']
            next_event_index = pointer['last_completed_event_index'] + 1
            events = self.current_story_unit.get('Events', [])
            event_data = events[next_event_index]
            _, event_content = list(event_data.items())[0]

            if not text.strip() and event_content: # ç”¨æˆ·ç›´æ¥å›è½¦ï¼Œä½¿ç”¨é»˜è®¤å€¼
                text = self._format_string(event_content)
                print(f"{TermColors.YELLOW}(ä½¿ç”¨é»˜è®¤): {text}{TermColors.RESET}")
            
            # --- æ–°å¢: å°†ç©å®¶çš„è¾“å…¥å­˜å…¥è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ ---
            # è¿™ä½¿å¾—ç´§éšå…¶åçš„äº‹ä»¶ï¼ˆå¦‚Action:Setï¼‰å¯ä»¥ä½¿ç”¨ {player_input}
            self.runtime_context['player_input'] = text

            self._add_to_dialogue_history('Player', content=text)
            pointer['last_completed_event_index'] = next_event_index
            self.progress['runtime_state'] = 'ExecutingEvents'
            self.run() # ç»§ç»­æ‰§è¡Œ
        
        elif state == 'InFreeTime':
            context = self.progress['free_time_context']
            end_condition = context['end_condition']
            exit_prompt = self._format_string(end_condition.get('ExitPromptInInputBox', ''))

            if exit_prompt and exit_prompt in text:
                log_info("æ£€æµ‹åˆ°é€€å‡ºè¯­ï¼Œè‡ªç”±æ—¶é—´ç»“æŸã€‚")
                self._transition_to_unit(end_condition['NextUnitID'])
                self.run()
                return

            # --- æ–°å¢: å°†ç©å®¶çš„è¾“å…¥å­˜å…¥è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ ---
            self.runtime_context['player_input'] = text
            
            self._add_to_dialogue_history('Player', content=text)
            
            # AI å›å¤ - ä½¿ç”¨æ™ºèƒ½è½®è¯¢æœºåˆ¶
            # ä¼˜å…ˆé€‰æ‹©DMè§’è‰²
            dm_char_id = self.global_config.get('dm_role_id')
            if dm_char_id and dm_char_id in self.character_files:
                ai_char_id = dm_char_id
            else:
                # å¦‚æœæ²¡æœ‰DMï¼Œåˆ™è¿›è¡Œè½®è¯¢
                all_ai_roles = self.global_config['character_roles']
                last_responder_index = self.progress.get('last_responder_index', -1)
                next_responder_index = (last_responder_index + 1) % len(all_ai_roles)
                ai_char_id = all_ai_roles[next_responder_index]
                self.progress['last_responder_index'] = next_responder_index  # è®°å½•æœ¬æ¬¡å“åº”è€…ç´¢å¼•
            
            ai_char_name = self.character_files[ai_char_id]['name']

            # --- ä¿®å¤ç‚¹ï¼šæ ¼å¼åŒ–AIè§’è‰²promptä¸­çš„æ¨¡æ¿å˜é‡ ---
            ai_system_prompt = self._format_string(self.character_files[ai_char_id]['prompt'])
            messages = [{"role": "system", "content": ai_system_prompt}]
            # æ·»åŠ å†å²
            for record in self.dialogue_history[-10:]:
                if record['type'] == 'Dialogue':
                     hist_char_id = record.get('data', {}).get('character_id')
                     role = "assistant" if hist_char_id == ai_char_id else "user"
                     content = record.get('content') or record.get('data', {}).get('content')
                     if content and hist_char_id:
                         messages.append({"role": role, "content": content})
                elif record['type'] == 'Player':
                     content = record.get('content') or record.get('data', {}).get('content')
                     if content:
                         messages.append({"role": "user", "content": content})
            
            response = chat_with_deepseek(messages, ai_char_name, color_code=TermColors.CYAN)
            if response:
                self._add_to_dialogue_history('Dialogue', character_id=ai_char_id, content=response)
            
            context['turns_taken'] += 1
            if end_condition['Type'] == 'LimitedFreeTime' and context['turns_taken'] >= end_condition['MaxTurns']:
                log_info("è¾¾åˆ°æœ€å¤§è½®æ¬¡ï¼Œè‡ªç”±æ—¶é—´ç»“æŸã€‚")
                self._transition_to_unit(end_condition['NextUnitID'])
                self.run()

        elif state == 'WaitingForPlayerChoice':
            context = self.progress['choice_context']
            if text in context['Branches']:
                branch = context['Branches'][text]
                self._transition_to_unit(branch['NextUnitID'])
                self.run()
            else:
                log_warning("æ— æ•ˆçš„é€‰æ‹©ï¼Œè¯·é‡æ–°è¾“å…¥ã€‚")
                print(f"{TermColors.RED}æ— æ•ˆé€‰æ‹©ï¼Œè¯·è¾“å…¥æ–¹æ‹¬å·å†…çš„å­—æ¯ã€‚{TermColors.RESET}")

    def _execute_ai_choice(self):
        """æ‰§è¡Œ AI é€‰æ‹©é€»è¾‘ï¼ŒåŒ…æ‹¬å†³ç­–å’Œåˆ¤æ–­ï¼Œç„¶åè½¬æ¢å‰§æƒ…å•å…ƒã€‚"""
        context = self.progress.get('ai_choice_context')
        if not context:
            log_error("æ— æ³•æ‰§è¡Œ AI Choiceï¼Œä¸Šä¸‹æ–‡ä¸­ç¼ºå°‘å¿…è¦ä¿¡æ¯ã€‚")
            self.game_over = True
            return

        decider_id = self._format_string(context['DeciderCharacterID'])
        decider_char = self.character_files.get(decider_id)
        if not decider_char:
            log_error(f"AI Choice å¤±è´¥ï¼šæ‰¾ä¸åˆ°å†³ç­–è§’è‰² '{decider_id}'ã€‚")
            self.game_over = True
            return
            
        # 1. æ„å»ºå†³ç­– LLM è¯·æ±‚ (Decision Call)
        decision_prompt = self._format_string(context['DecisionPromptForAI'])
        decision_messages = []
        # --- ä¿®å¤ç‚¹ï¼šæ ¼å¼åŒ–å†³ç­–è§’è‰²promptä¸­çš„æ¨¡æ¿å˜é‡ ---
        decider_system_prompt = self._format_string(decider_char['prompt'])
        decision_messages.append({"role": "system", "content": decider_system_prompt})
        
        # æ·»åŠ å¯¹è¯å†å² (ä¸ Dialogue Prompt é€»è¾‘ç›¸åŒ)
        for record in self.dialogue_history[-15:]:  # å¯ä»¥é€‚å½“å¢åŠ å†å²è®°å½•é•¿åº¦
            # ä»è®°å½•ä¸­è·å–çº¯æ–‡æœ¬å†…å®¹
            content = record.get('content') or record.get('data', {}).get('content')
            if not content:
                continue

            if record['type'] == 'Dialogue':
                hist_char_id = record.get('data', {}).get('character_id')
                if hist_char_id:
                    # æ ¹æ®å†³ç­–è€…ID (decider_id) æ¥å†³å®šå†å²è®°å½•ä¸­çš„è§’è‰²æ˜¯ 'assistant' è¿˜æ˜¯ 'user'
                    role = "assistant" if hist_char_id == decider_id else "user"
                    decision_messages.append({"role": role, "content": content})
            elif record['type'] == 'Player':
                # ç©å®¶çš„å‘è¨€å¯¹å†³ç­–AIæ¥è¯´éƒ½æ˜¯ 'user'
                decision_messages.append({"role": "user", "content": content})
        
        decision_messages.append({"role": "system", "content": decision_prompt})

        # è°ƒç”¨LLMè·å–å†³ç­–æ–‡æœ¬ (è¿™é‡Œä¸ç›´æ¥æ‰“å°ï¼Œæ˜¯AIçš„å†…å¿ƒæ€è€ƒ)
        log_info(f"æ­£åœ¨ä¸ºè§’è‰² {decider_char['name']} è·å–å†³ç­–...")
        ai_decision_text = chat_with_deepseek(decision_messages, character_name=f"{decider_char['name']}(å†…å¿ƒ)", is_internal_thought=True, color_code=TermColors.CYAN)

        if not ai_decision_text:
            log_error("AI æœªèƒ½åšå‡ºå†³ç­–ï¼Œå‰§æƒ…æ— æ³•ç»§ç»­ã€‚")
            self.game_over = True
            return
            
        log_debug(f"AI å†³ç­–åŸæ–‡: {ai_decision_text}")

        # 2. æ„å»ºåˆ¤æ–­ LLM è¯·æ±‚ (Judge Call)
        judge_prompt = self._format_string(context['JudgePromptForSystem'])
        judge_messages = [
            {"role": "system", "content": judge_prompt},
            {"role": "user", "content": f"è¯·æ ¹æ®ä»¥ä¸‹AIè§’è‰²çš„å†³ç­–æ–‡æœ¬è¿›è¡Œåˆ¤æ–­ï¼š\n\n---\n{ai_decision_text}\n---"}
        ]
        
        log_info("ç³»ç»Ÿæ­£åœ¨åˆ¤æ–­ AI çš„é€‰æ‹©...")
        judged_result = chat_with_deepseek(judge_messages, character_name="ç³»ç»Ÿåˆ¤æ–­", is_internal_thought=True, color_code=TermColors.CYAN)
        
        if not judged_result:
            log_error("ç³»ç»Ÿæœªèƒ½åˆ¤æ–­ AI çš„å†³ç­–ï¼Œå‰§æƒ…æ— æ³•ç»§ç»­ã€‚")
            self.game_over = True
            return

        # 3. å¤„ç†ç»“æœå¹¶è½¬æ¢å‰§æƒ…å•å…ƒ
        final_choice = judged_result.strip().upper()
        log_info_color(f"AI çš„é€‰æ‹©å·²è¢«ç³»ç»Ÿåˆ¤æ–­ä¸º: '{final_choice}'", TermColors.GREEN)

        if final_choice in context['Branches']:
            next_unit_id = context['Branches'][final_choice]
            # æ¸…ç†ä¸Šä¸‹æ–‡å¹¶è½¬æ¢
            del self.progress['ai_choice_context']
            self._transition_to_unit(next_unit_id)
            self.run()  # ç«‹å³ç»§ç»­æ¸¸æˆå¾ªç¯
        else:
            log_error(f"åˆ¤æ–­ç»“æœ '{final_choice}' æ— æ•ˆï¼Œåœ¨ Branches ä¸­æ‰¾ä¸åˆ°åŒ¹é…é¡¹ã€‚")
            self.game_over = True
```

### æ–‡ä»¶: `llm_interface.py`

```python
# llm_interface.py
import requests
import json
import sys
import time

import config
from logger import (
    log_debug,
    log_info_color,
    log_warning,
    log_error_color,
    start_loading_animation,
    stop_loading_animation,
    TermColors
)

def chat_with_deepseek(messages_payload, character_name="AI", is_internal_thought=False, color_code=TermColors.CYAN):
    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {config.API_KEY}"}
    payload = {
        "model": config.MODEL_NAME, "messages": messages_payload, "stream": True,
        "max_tokens": config.MAX_TOKENS, "temperature": config.TEMPERATURE
    }

    if config.DEBUG_MODE:
        log_debug(f"--- å‘é€ç»™ DeepSeek API çš„ Payload (è§’è‰²: {character_name}) ---")
        debug_payload_display = json.loads(json.dumps(payload))
        for msg in debug_payload_display.get("messages", []):
            if 'content' in msg and isinstance(msg['content'], str):
                msg['content'] = msg['content'].replace('\n', ' ')[:150] + ("..." if len(msg['content']) > 150 else "")
        formatted_payload_str = json.dumps(debug_payload_display, ensure_ascii=False, indent=2)
        for line in formatted_payload_str.splitlines(): log_debug(line)
        log_debug("--- Payload ç»“æŸ ---")

    assistant_full_response = ""
    api_call_succeeded = False
    animation_stopped_internally = False

    try:
        if not is_internal_thought:
            animation_msg = f"{TermColors.LIGHT_BLUE}{character_name} æ­£åœ¨æ€è€ƒ...{TermColors.RESET}"
            start_loading_animation(
                message=animation_msg,
                animation_style_key='moon',
            )

        response = requests.post(config.API_URL, headers=headers, json=payload, stream=True,
                                 timeout=config.API_TIMEOUT_SECONDS)
        response.raise_for_status()

        first_chunk_received = False
        for chunk in response.iter_lines():
            if chunk:
                decoded_line = chunk.decode('utf-8')
                if decoded_line.startswith("data: "):
                    json_data_str = decoded_line[len("data: "):]
                    if json_data_str.strip() == "[DONE]":
                        break
                    try:
                        data = json.loads(json_data_str)
                        content_piece = data.get("choices", [{}])[0].get("delta", {}).get("content", "")
                        if content_piece:
                            if not is_internal_thought:
                                if not first_chunk_received:
                                    stop_loading_animation()
                                    animation_stopped_internally = True
                                    print(f"{color_code}{character_name}:{TermColors.RESET} ", end="", flush=True)
                                    first_chunk_received = True
                                sys.stdout.write(f"{color_code}{content_piece}{TermColors.RESET}")
                                sys.stdout.flush()
                            assistant_full_response += content_piece
                    except (json.JSONDecodeError, IndexError):
                        log_warning(f"API Stream: è§£ç æˆ–ç´¢å¼•é”™è¯¯ï¼Œæ•°æ®å—: {json_data_str}")

        if not is_internal_thought:
            if first_chunk_received:
                print()
                api_call_succeeded = True
            elif response.ok:
                log_warning("API å“åº”æµç»“æŸï¼Œä½†æœªè¿”å›ä»»ä½•æ–‡æœ¬å†…å®¹ã€‚")
                api_call_succeeded = True
        else:
            # å†…éƒ¨æ€è€ƒæ¨¡å¼ï¼Œåªè¦æœ‰å“åº”å°±ç®—æˆåŠŸ
            api_call_succeeded = response.ok

    except requests.exceptions.HTTPError as e:
        log_error_color(f"\nAPIè¯·æ±‚HTTPé”™è¯¯: {e} - {e.response.status_code} {e.response.reason}")
        try:
            log_error_color(f"é”™è¯¯è¯¦æƒ…: {json.dumps(e.response.json(), ensure_ascii=False, indent=2)}")
        except ValueError:
            log_error_color(f"é”™è¯¯å“åº”ä½“ (éJSON): {e.response.text}")
    except requests.exceptions.RequestException as e:
        log_error_color(f"\nAPIè¯·æ±‚å¤±è´¥: {e}")
    finally:
        if not is_internal_thought and not animation_stopped_internally:
            stop_loading_animation(success=api_call_succeeded, final_message="ä¸APIé€šä¿¡ä¸­æ–­" if not api_call_succeeded else None)

    return assistant_full_response if api_call_succeeded else None
```

### æ–‡ä»¶: `logger.py`

```python
# logger.py
import logging
import sys
import time
import threading
from datetime import datetime
import os
import re  # Import re for ANSI stripping

# æ—¥å¿—é…ç½®
ENABLE_FILE_LOGGING = True  # æ˜¯å¦å¯ç”¨æ–‡ä»¶æ—¥å¿—è®°å½•
LOG_FILE_DIRECTORY = "run_logs"  # æ—¥å¿—æ–‡ä»¶å­˜å‚¨çš„ç›¸å¯¹ç›®å½•

# æ³¨æ„ï¼Œè‹¥ç¯å¢ƒå˜é‡DEBUG_MODE = True/falseæ—¶ï¼Œä¼šè¦†ç›–LOG_FILE_LEVELçš„è®¾ç½®
LOG_FILE_LEVEL = logging.DEBUG  # å¯ä»¥è®¾ç½®ä¸º logging.DEBUGï¼Œlogging.INFO, logging.WARNING, logging.ERROR

ANIMATION_STYLES = {
    'braille': ['â¢¿', 'â£»', 'â£½', 'â£¾', 'â£·', 'â£¯', 'â£Ÿ', 'â¡¿'],
    'spinner': ['-', '\\', '|', '/'],
    'dots': ['.  ', '.. ', '...', ' ..', '  .', '   '],
    'arrows': ['â†', 'â†–', 'â†‘', 'â†—', 'â†’', 'â†˜', 'â†“', 'â†™'],
    'moon': ['ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜'],
    'clock': ['ğŸ•›', 'ğŸ•', 'ğŸ•‘', 'ğŸ•’', 'ğŸ•“', 'ğŸ•”', 'ğŸ••', 'ğŸ•–', 'ğŸ•—', 'ğŸ•˜', 'ğŸ•™', 'ğŸ•š'],
    'directional_arrows_unicode': ['â¬†ï¸', 'â†—ï¸', 'â¡ï¸', 'â†˜ï¸', 'â¬‡ï¸', 'â†™ï¸', 'â¬…ï¸', 'â†–ï¸'],
    'traffic_lights': ['ğŸ”´', 'ğŸŸ¡', 'ğŸŸ¢'],
    'growth_emoji': ['ğŸŒ±', 'ğŸŒ¿', 'ğŸŒ³'],
    'weather_icons': ['â˜€ï¸', 'â˜ï¸', 'ğŸŒ§ï¸', 'âš¡ï¸'],
    'heartbeat': ['â™¡', 'â™¥'],
}

_ansi_escape_regex = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')

def _strip_ansi_codes(text):
    """Removes ANSI escape codes from a string."""
    return _ansi_escape_regex.sub('', text)

sys.stderr.flush()

def wcswidth(s):
    """å›é€€ wcswidth, å°†é ASCII å­—ç¬¦è§†ä¸ºå®½åº¦2ã€‚åº”åœ¨å‰¥ç¦»ANSIç åä½¿ç”¨ã€‚"""
    if not isinstance(s, str):
        return len(s) if s else 0
    length = 0
    for char_ in s:  # Assumes s is already stripped of ANSI codes
        if ord(char_) < 128:
            length += 1
        else:
            length += 2
    return length

class TermColors:
    GREY = '\033[90m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    RESET = '\033[0m'
    WHITE = '\033[97m'
    CYAN = '\033[96m'
    MAGENTA = '\033[95m'
    LIGHT_BLUE = '\033[94m'  # Actually same as BLUE in this list, but kept for intent
    ORANGE = '\033[38;5;208m'

_logger = None
_animation_thread = None
_stop_animation_event = threading.Event()

_is_animating = False
_current_animation_line_width = 0
_animation_state_lock = threading.Lock()

DEFAULT_ANIMATION_STYLE_KEY = 'braille'
DEFAULT_ANIMATION_COLOR = TermColors.WHITE  # Default color for animation if not specified

class AnimationAwareStreamHandler(logging.StreamHandler):
    def emit(self, record):
        global _is_animating, _current_animation_line_width, _animation_state_lock

        if hasattr(record, 'is_animation_control') and record.is_animation_control:
            super().emit(record)
            return

        current_animation_active_locally = False
        current_width_to_clear_locally = 0

        with _animation_state_lock:
            current_animation_active_locally = _is_animating
            current_width_to_clear_locally = _current_animation_line_width

        if current_animation_active_locally and current_width_to_clear_locally > 0:
            self.acquire()
            try:
                self.flush()
                # Ensure the full line is cleared, then cursor to start
                self.stream.write("\r" + " " * current_width_to_clear_locally + "\r")
                self.stream.flush()
            finally:
                self.release()

        super().emit(record)

class ColoredFormatter(logging.Formatter):
    DATE_FORMAT = "%Y-%m-%d-%H:%M:%S"

    def __init__(self, show_timestamp=True):
        super().__init__(datefmt=self.DATE_FORMAT)
        self.show_timestamp = show_timestamp

    def format(self, record):
        if hasattr(record, 'is_animation_control') and record.is_animation_control:
            return record.getMessage()

        timestamp_part = ""
        if self.show_timestamp:
            timestamp_str = self.formatTime(record, self.DATE_FORMAT)
            timestamp_part = f"{timestamp_str} "

        message_content = record.getMessage()
        level_name = record.levelname
        level_prefix_text = f"[{level_name}]: "

        if record.levelno == logging.DEBUG:
            return f"{TermColors.GREY}{timestamp_part}{level_prefix_text}{message_content}{TermColors.RESET}"

        level_color = ""
        if record.levelno == logging.INFO:
            level_color = TermColors.GREEN
        elif record.levelno == logging.WARNING:
            level_color = TermColors.YELLOW
        elif record.levelno == logging.ERROR:
            level_color = TermColors.RED

        colored_level_prefix = f"{level_color}{level_prefix_text}{TermColors.RESET}"
        return f"{timestamp_part}{colored_level_prefix}{message_content}"


def _animate(message="Loading", animation_chars=None, color_code=DEFAULT_ANIMATION_COLOR):
    global _is_animating, _current_animation_line_width, _animation_state_lock, _stop_animation_event

    if animation_chars is None:
        animation_chars = ANIMATION_STYLES[DEFAULT_ANIMATION_STYLE_KEY]

    idx = 0
    last_char_for_clear = animation_chars[0]

    while not _stop_animation_event.is_set():
        char = animation_chars[idx % len(animation_chars)]
        last_char_for_clear = char

        full_animation_line_with_ansi = f"{color_code}{message} {char}{TermColors.RESET} "

        stripped_line_for_width = _strip_ansi_codes(full_animation_line_with_ansi)
        current_visible_width = wcswidth(stripped_line_for_width)

        with _animation_state_lock:
            _current_animation_line_width = current_visible_width

        sys.stdout.write(f"\r{full_animation_line_with_ansi}")
        sys.stdout.flush()

        idx += 1
        time.sleep(0.12)

    final_animation_line_to_clear_ansi = f"{color_code}{message} {last_char_for_clear}{TermColors.RESET} "
    stripped_final_line = _strip_ansi_codes(final_animation_line_to_clear_ansi)
    width_to_clear = wcswidth(stripped_final_line)

    sys.stdout.write("\r" + " " * width_to_clear + "\r")
    sys.stdout.flush()

    with _animation_state_lock:
        _is_animating = False
        _current_animation_line_width = 0


def start_loading_animation(message="Processing",
                            animation_style_key=DEFAULT_ANIMATION_STYLE_KEY,
                            animation_color=DEFAULT_ANIMATION_COLOR):
    global _animation_thread, _stop_animation_event, _is_animating, _current_animation_line_width, _animation_state_lock

    with _animation_state_lock:
        if _is_animating:
            log_debug("Animation already running, not starting another one.")
            return

        _stop_animation_event.clear()
        selected_chars = ANIMATION_STYLES.get(animation_style_key, ANIMATION_STYLES[DEFAULT_ANIMATION_STYLE_KEY])

        initial_char = selected_chars[0]
        initial_full_line_ansi = f"{animation_color}{message} {initial_char}{TermColors.RESET} "
        stripped_initial_line = _strip_ansi_codes(initial_full_line_ansi)
        initial_width = wcswidth(stripped_initial_line)

        _is_animating = True
        _current_animation_line_width = initial_width

        _animation_thread = threading.Thread(target=_animate,
                                             args=(message, selected_chars, animation_color),
                                             daemon=True)
        _animation_thread.start()


def stop_loading_animation(success=True, final_message=None):
    global _animation_thread, _stop_animation_event, _is_animating, _animation_state_lock

    was_animating_when_called = False
    with _animation_state_lock:
        if _is_animating or _animation_thread is not None:
            was_animating_when_called = True
            _stop_animation_event.set()

    if not was_animating_when_called:
        if final_message:
            if success:
                log_info(f"{TermColors.GREEN}âœ”{TermColors.RESET} {final_message}")
            else:
                log_error(f"{TermColors.RED}âœ–{TermColors.RESET} {final_message}")
        return

    current_thread_ref = _animation_thread
    if current_thread_ref and current_thread_ref.is_alive():
        current_thread_ref.join(timeout=2)

    with _animation_state_lock:
        _is_animating = False
        _current_animation_line_width = 0
        _animation_thread = None

    if final_message:
        if success:
            log_info(f"{TermColors.GREEN}âœ”{TermColors.RESET} {final_message}")
        else:
            log_error(f"{TermColors.RED}âœ–{TermColors.RESET} {final_message}")

def initialize_logger(app_name="AppLogger", config_debug_mode=True, show_timestamp=True):
    global _logger
    _logger = logging.getLogger(app_name)
    _logger.propagate = False

    if config_debug_mode:
        _logger.setLevel(logging.DEBUG)
    else:
        _logger.setLevel(logging.INFO)

    if _logger.hasHandlers():
        for handler in _logger.handlers[:]:
            handler.close()
            _logger.removeHandler(handler)

    console_handler = AnimationAwareStreamHandler(sys.stdout)
    console_formatter = ColoredFormatter(show_timestamp=show_timestamp)
    console_handler.setFormatter(console_formatter)
    _logger.addHandler(console_handler)

    if ENABLE_FILE_LOGGING:
        try:
            if not os.path.exists(LOG_FILE_DIRECTORY):
                os.makedirs(LOG_FILE_DIRECTORY, exist_ok=True)

            log_filename = datetime.now().strftime(f"{app_name}_%Y-%m-%d_%H-%M-%S.log")
            log_filepath = os.path.join(LOG_FILE_DIRECTORY, log_filename)

            file_handler = logging.FileHandler(log_filepath, encoding='utf-8')
            file_formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                datefmt=ColoredFormatter.DATE_FORMAT
            )
            file_handler.setFormatter(file_formatter)
            file_handler.setLevel(LOG_FILE_LEVEL)
            _logger.addHandler(file_handler)
        except Exception as e:
            sys.stderr.write(
                f"{TermColors.RED}é”™è¯¯: åˆå§‹åŒ–æ–‡ä»¶æ—¥å¿—è®°å½•å¤±è´¥: {e}{TermColors.RESET}\n"
            )
            sys.stderr.flush()
    return _logger

def get_logger():
    global _logger
    if _logger is None:
        sys.stderr.write(
            f"{TermColors.YELLOW}è­¦å‘Š: æ—¥å¿—è®°å½•å™¨åœ¨æ˜¾å¼åˆå§‹åŒ–ä¹‹å‰è¢«è®¿é—®ã€‚ "
            f"å°†ä½¿ç”¨é»˜è®¤å€¼è¿›è¡Œåˆå§‹åŒ–ã€‚{TermColors.RESET}\n"
        )
        sys.stderr.flush()
        _logger = initialize_logger()
    return _logger

def log_debug(message, *args, **kwargs): get_logger().debug(message, *args, **kwargs)

def log_info(message, *args, **kwargs): get_logger().info(message, *args, **kwargs)

def log_warning(message, *args, **kwargs): get_logger().warning(message, *args, **kwargs)

def log_error(message, *args, **kwargs): get_logger().error(message, *args, **kwargs)

def log_info_color(message, color_code=TermColors.GREEN, *args, **kwargs):
    get_logger().info(f"{color_code}{message}{TermColors.RESET}", *args, **kwargs)

def log_warning_color(message, color_code=TermColors.YELLOW, *args, **kwargs):
    get_logger().warning(f"{color_code}{message}{TermColors.RESET}", *args, **kwargs)

def log_error_color(message, color_code=TermColors.RED, *args, **kwargs):
    get_logger().error(f"{color_code}{message}{TermColors.RESET}", *args, **kwargs)

def log_rag_output(message, *args, **kwargs):  # Example of a domain-specific logger
    get_logger().info(f"{TermColors.BLUE}{message}{TermColors.RESET}", *args, **kwargs)

if __name__ == "__main__":
    # 1. Initialize logger - app_name will be part of the log file name
    initialize_logger(app_name="æ¼”ç¤ºåº”ç”¨", config_debug_mode=True, show_timestamp=True)
    log_info("=============== ç‚«å½©æ—¥å¿—ä¸åŠ è½½åŠ¨ç”»æ¼”ç¤ºå¼€å§‹ ===============")
    log_debug("è¿™æ˜¯ä¸€ä¸ªè°ƒè¯•æ¶ˆæ¯ï¼šæ—¥å¿—ç³»ç»Ÿå·²æˆåŠŸåˆå§‹åŒ–ã€‚")
    if not ENABLE_FILE_LOGGING:
        log_warning("æ–‡ä»¶æ—¥å¿—è®°å½•å·²ç¦ç”¨ã€‚å¦‚éœ€å¯ç”¨ï¼Œè¯·è®¾ç½® ENABLE_FILE_LOGGING = True")
    else:
        log_info(f"æ–‡ä»¶æ—¥å¿—å·²å¯ç”¨ï¼Œæ—¥å¿—å°†å­˜å‚¨åœ¨ '{LOG_FILE_DIRECTORY}' ç›®å½•ä¸‹ã€‚")

    # 2. Basic log levels demo
    log_info("æ¼”ç¤º2.1: log_infoæ˜¯ä¸€æ¡ INFO ä¿¡æ¯ã€‚")
    log_warning("æ¼”ç¤º2.2: log_warningæ˜¯ä¸€æ¡è­¦å‘Š WARNING ä¿¡æ¯ã€‚")
    log_error("æ¼”ç¤º2.3: log_erroræ˜¯ä¸€æ¡é”™è¯¯ ERROR ä¿¡æ¯ã€‚")
    log_debug("æ¼”ç¤º2.4: log_debugæ˜¯ä¸€æ¡è°ƒè¯• DEBUG ä¿¡æ¯ã€‚DEBUGä¿¡æ¯ï¼ˆåŒ…æ‹¬å¯¹åº”æ—¶é—´æˆ³ï¼‰å…¨éƒ¨ä¿æŒç°è‰²")

    log_info_color("æ¼”ç¤º2.5: log_info_colorçš„ INFO ä¿¡æ¯é»˜è®¤å¸¦æœ‰é†’ç›®çš„ç»¿è‰²ã€‚")
    log_info_color("å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥è‡ªå®šä¹‰log_info_colorçš„é¢œè‰²", TermColors.MAGENTA)
    log_warning_color("æ¼”ç¤º2.6: log_warning_colorçš„ WARNING ä¿¡æ¯é»˜è®¤å¸¦æœ‰é†’ç›®çš„é»„è‰²ã€‚")
    log_warning_color("å½“ç„¶ä½ ä¹Ÿå¯ä»¥æ”¹æˆè“çš„", TermColors.BLUE)
    log_error_color("æ¼”ç¤º2.7: log_error_colorçš„ ERROR ä¿¡æ¯é»˜è®¤å¸¦æœ‰é†’ç›®çš„çº¢è‰²ã€‚")
    log_error_color("ä¸€ä¸ªç»¿è‰²çš„ERROR?", TermColors.GREEN)

    # 3. Loading animation demo
    log_info("æ¼”ç¤º3.1: é»˜è®¤åŠ è½½åŠ¨ç”» (brailleæ ·å¼, é»˜è®¤ç™½è‰²)")
    # Pass message without internal colors, use animation_color for the whole line
    start_loading_animation(message="ä»»åŠ¡Aå¤„ç†ä¸­")
    time.sleep(2)
    stop_loading_animation(success=True, final_message="ä»»åŠ¡AæˆåŠŸå®Œæˆ!")

    log_info("æ¼”ç¤º3.2: è‡ªå®šä¹‰åŠ¨ç”»æ ·å¼ (spinneræ ·å¼, é»˜è®¤ç™½è‰²)")
    start_loading_animation(message="ä»»åŠ¡Bæ‰§è¡Œä¸­", animation_style_key='spinner')
    time.sleep(2)
    stop_loading_animation(success=True, final_message="ä»»åŠ¡B (spinner) æ‰§è¡Œå®Œæ¯•!")

    log_info("æ¼”ç¤º3.3: è‡ªå®šä¹‰åŠ¨ç”»é¢œè‰² (é»˜è®¤brailleæ ·å¼, é’è‰²)")
    start_loading_animation(message="ä»»åŠ¡CåŠ è½½ä¸­", animation_color=TermColors.CYAN)
    time.sleep(2)
    stop_loading_animation(success=True, final_message="ä»»åŠ¡C (é’è‰²) åŠ è½½å®Œæˆ!")

    log_info("æ¼”ç¤º3.4: ä¼ é€’æœ¬èº«å¸¦é¢œè‰²çš„æ¶ˆæ¯ç»™åŠ¨ç”»")
    # This shows that message can carry its own colors, and animation_color is an outer wrapper
    # animation_color (default WHITE) wraps (MAGENTA "Task D" RESET) + char + RESET
    start_loading_animation(
        message=f"{TermColors.MAGENTA}ä»»åŠ¡D(æœ¬èº«å“çº¢){TermColors.RESET}è¿›è¡Œä¸­",
        animation_style_key='arrows',
        animation_color=TermColors.YELLOW  # Yellow wrapper
    )
    time.sleep(2.5)
    stop_loading_animation(success=True, final_message="ä»»åŠ¡D (å“çº¢å†…å®¹ï¼Œé»„è‰²åŒ…è£…) å®Œæˆ!")

    log_info("æ¼”ç¤º3.5: å…¶ä»–åŠ¨ç”»æ ·å¼ (moonæ ·å¼, æµ…è“è‰²)")
    start_loading_animation(message="æœˆç›¸è§‚å¯Ÿ", animation_style_key='moon', animation_color=TermColors.LIGHT_BLUE)
    time.sleep(2.5)
    stop_loading_animation(success=True, final_message="æœˆç›¸è§‚å¯Ÿå®Œæ¯•!")

    log_info("æ¼”ç¤º3.6: åŠ¨ç”»æœŸé—´è¿›è¡Œæ—¥å¿—è®°å½• (dotsæ ·å¼, æ©™è‰²)")
    start_loading_animation(message="æ©™è‰²ç‚¹ç‚¹ä»»åŠ¡", animation_style_key='dots', animation_color=TermColors.ORANGE)
    log_info("åŠ¨ç”»å·²å¯åŠ¨ï¼Œç°åœ¨è®°å½•ä¸€æ¡ INFO æ¶ˆæ¯ï¼ŒåŠ¨ç”»ä¼šè‡ªåŠ¨é¿è®©ã€‚")
    time.sleep(1)
    log_warning("è¿™æ˜¯ä¸€æ¡è­¦å‘Š WARNING æ¶ˆæ¯ï¼ŒåŠ¨ç”»ä»åœ¨åå°ç»§ç»­ã€‚")
    time.sleep(1)
    log_debug("ä¸€æ¡è°ƒè¯• DEBUG æ¶ˆæ¯ï¼ŒåŠ¨ç”»å³å°†åœæ­¢å¹¶æ¨¡æ‹Ÿå¤±è´¥ã€‚")
    time.sleep(1)
    stop_loading_animation(success=False, final_message="æ©™è‰²ç‚¹ç‚¹ä»»åŠ¡æ¨¡æ‹Ÿå¤±è´¥ã€‚")

    log_info("æ¼”ç¤º3.7: åœæ­¢åŠ¨ç”»æ—¶ä¸æ˜¾ç¤ºæœ€ç»ˆæ¶ˆæ¯")
    start_loading_animation(message="çŸ­æš‚å¤„ç†")
    time.sleep(1.5)
    stop_loading_animation()  # No final_message
    log_info("åŠ¨ç”»å·²åœæ­¢ï¼Œä¸æä¾› final_messageã€‚")

    # 4. Special color log functions
    log_info("æ¼”ç¤º4.1: ä½¿ç”¨ log_info_color è¾“å‡ºè‡ªå®šä¹‰é¢œè‰² INFO (ä¾‹å¦‚ç´«çº¢è‰²)")
    log_info_color("è¿™æ˜¯ä¸€æ¡ç´«çº¢è‰²çš„ INFO ä¿¡æ¯ã€‚", TermColors.MAGENTA)

    log_info("æ¼”ç¤º4.2: ä½¿ç”¨ log_rag_output è¾“å‡ºç‰¹å®šæ ¼å¼ INFO")
    log_rag_output("è¿™æ˜¯ä¸€ä¸ªRAG æ¨¡å‹è¾“å‡ºå†…å®¹ (è“è‰²)")

    # 5. Re-initialize logger: turn off console timestamp
    log_info("æ¼”ç¤º5: é‡æ–°åˆå§‹åŒ–æ—¥å¿—ï¼Œå…³é—­æ§åˆ¶å°æ—¶é—´æˆ³ (æ–‡ä»¶æ—¥å¿—ä¸å—å½±å“)")
    initialize_logger(app_name="æ¼”ç¤ºåº”ç”¨-æ— æ—¶é—´æˆ³", config_debug_mode=True, show_timestamp=False)
    log_info("è¿™æ¡ INFO ä¿¡æ¯åœ¨æ§åˆ¶å°ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ã€‚")
    log_debug("è¿™æ¡ DEBUG ä¿¡æ¯åœ¨æ§åˆ¶å°ä¹Ÿä¸æ˜¾ç¤ºæ—¶é—´æˆ³ã€‚")
    start_loading_animation(message="æ— æ—¶é—´æˆ³ä»»åŠ¡æ‰§è¡Œ")
    time.sleep(1.5)
    stop_loading_animation(final_message="æ— æ—¶é—´æˆ³ä»»åŠ¡å®Œæˆã€‚")

    # 6. Restore timestamp and test print() interaction
    log_info("æ¼”ç¤º6: æ¢å¤æ—¶é—´æˆ³å¹¶æµ‹è¯•åŠ¨ç”»ä¸æ™®é€š print() è¯­å¥çš„äº¤äº’")
    initialize_logger(app_name="æ¼”ç¤ºåº”ç”¨", config_debug_mode=True, show_timestamp=True)  # Restore default
    log_info("æ—¥å¿—æ—¶é—´æˆ³å·²æ¢å¤ã€‚")

    print(f"{TermColors.YELLOW}è¿™æ˜¯ä¸€æ¡æ™®é€šçš„ print() è¯­å¥ï¼Œåœ¨åŠ¨ç”»å¼€å§‹å‰ã€‚{TermColors.RESET}")
    start_loading_animation(message="æµ‹è¯•ä¸printäº¤äº’")
    time.sleep(1)
    # Standard print() is not intercepted by the logger's handler.
    # It will likely mess up the animation line.
    print(f"{TermColors.RED}è­¦å‘Š: ä¸‹é¢è¿™æ¡ print() è¯­å¥ä¼šæ‰“æ–­å½“å‰åŠ¨ç”»è¡Œã€‚{TermColors.RESET}")
    time.sleep(1)
    log_info("è¿™æ¡æ—¥å¿—æ¶ˆæ¯åœ¨ print() ä¹‹åï¼Œä¼šç”± AnimationAwareStreamHandler æ­£ç¡®å¤„ç†ã€‚")
    time.sleep(1)
    stop_loading_animation(final_message="åŠ¨ç”»ä¸ print() äº¤äº’æµ‹è¯•ç»“æŸã€‚")
    print(f"{TermColors.GREEN}åŠ¨ç”»ç»“æŸåçš„å¦ä¸€æ¡ print() è¯­å¥ã€‚{TermColors.RESET}")

    # 7. End
    if ENABLE_FILE_LOGGING:
        log_info(f"æ‰€æœ‰æ¼”ç¤ºå·²å®Œæˆã€‚è¯·æ£€æŸ¥ '{LOG_FILE_DIRECTORY}' ç›®å½•ä¸­çš„æ—¥å¿—æ–‡ä»¶ã€‚")
    else:
        log_info("æ‰€æœ‰æ¼”ç¤ºå·²å®Œæˆã€‚æ–‡ä»¶æ—¥å¿—è®°å½•å½“å‰å·²ç¦ç”¨ã€‚")
    log_info("=============== æ¼”ç¤ºç»“æŸ ===============")
```

### æ–‡ä»¶: `main.py`

```python
# main.py
import os
import sys
from datetime import datetime

import config
from logger import initialize_logger, log_info, log_error, log_warning, log_debug, log_info_color, TermColors
from game_engine import GameEngine

def select_from_list(items, prompt):
    if not items:
        return None
    for i, item in enumerate(items):
        print(f"  [{i + 1}] {item}")
    while True:
        try:
            choice = input(f"{prompt} (è¾“å…¥æ•°å­—): ")
            choice_idx = int(choice) - 1
            if 0 <= choice_idx < len(items):
                return items[choice_idx]
            else:
                print(f"{TermColors.RED}æ— æ•ˆçš„æ•°å­—ï¼Œè¯·è¾“å…¥ 1 åˆ° {len(items)} ä¹‹é—´çš„æ•°å­—ã€‚{TermColors.RESET}")
        except ValueError:
            print(f"{TermColors.RED}æ— æ•ˆçš„è¾“å…¥ï¼Œè¯·è¾“å…¥æ•°å­—ã€‚{TermColors.RESET}")

def start_new_game():
    log_info("å¼€å§‹æ–°æ¸¸æˆæµç¨‹...")
    
    # 1. é€‰æ‹©å‰§æœ¬
    packs_path = config.STORY_PACKS_BASE_PATH
    available_packs = [d for d in os.listdir(packs_path) if os.path.isdir(os.path.join(packs_path, d))]
    if not available_packs:
        log_error(f"åœ¨ '{packs_path}' ç›®å½•ä¸‹æœªæ‰¾åˆ°ä»»ä½•å‰§æœ¬åŒ…ã€‚")
        return None
    
    print(f"\n{TermColors.YELLOW}è¯·é€‰æ‹©ä¸€ä¸ªå‰§æœ¬åŒ…ï¼š{TermColors.RESET}")
    chosen_pack_name = select_from_list(available_packs, "é€‰æ‹©å‰§æœ¬")
    if not chosen_pack_name: return None
    chosen_pack_path = os.path.join(packs_path, chosen_pack_name)

    # 2. è¯»å–å‰§æœ¬é…ç½®ï¼Œç¡®å®šæ‰€éœ€è§’è‰²
    try:
        with open(os.path.join(chosen_pack_path, 'å…¨å±€å‰§æƒ…é…ç½®.yaml'), 'r', encoding='utf-8') as f:
            pack_config = yaml.safe_load(f)
        required_roles = pack_config['character_roles']
    except (FileNotFoundError, KeyError, yaml.YAMLError) as e:
        log_error(f"è¯»å–å‰§æœ¬ '{chosen_pack_name}' çš„é…ç½®å¤±è´¥: {e}")
        return None
    
    # 3. ä¸ºæ¯ä¸ªè§’è‰²é€‰æ‹©äººè®¾
    chars_path = config.CHARACTERS_BASE_PATH
    available_chars = [f for f in os.listdir(chars_path) if f.endswith('.yaml')]
    if not available_chars:
        log_error(f"åœ¨ '{chars_path}' ç›®å½•ä¸‹æœªæ‰¾åˆ°ä»»ä½•äººè®¾æ–‡ä»¶ã€‚")
        return None
    
    character_selections = {}
    print(f"\n{TermColors.YELLOW}è¯·ä¸ºå‰§æœ¬ä¸­çš„æ¯ä¸ªè§’è‰²é€‰æ‹©ä¸€ä¸ªäººè®¾ï¼š{TermColors.RESET}")
    for role_id in required_roles:
        print(f"--- ä¸ºè§’è‰² '{role_id}' é€‰æ‹©äººè®¾ ---")
        chosen_char_file = select_from_list(available_chars, f"é€‰æ‹©äººè®¾")
        if not chosen_char_file: return None
        character_selections[role_id] = os.path.join(chars_path, chosen_char_file)
        # ä»åˆ—è¡¨ä¸­ç§»é™¤å·²é€‰çš„è§’è‰²ï¼Œé¿å…é‡å¤é€‰æ‹©
        available_chars.remove(chosen_char_file)

    # 4. åˆå§‹åŒ–æ¸¸æˆå¼•æ“
    engine = GameEngine()
    if engine.load_story_pack(chosen_pack_path, character_selections):
        return engine
    return None

def load_game_from_save():
    log_info("åŠ è½½æ¸¸æˆå­˜æ¡£...")
    saves_path = config.SAVES_BASE_PATH
    available_saves = [d for d in os.listdir(saves_path) if os.path.isdir(os.path.join(saves_path, d))]
    if not available_saves:
        log_warning("æœªæ‰¾åˆ°ä»»ä½•å­˜æ¡£ã€‚")
        return None

    print(f"\n{TermColors.YELLOW}è¯·é€‰æ‹©ä¸€ä¸ªå­˜æ¡£åŠ è½½ï¼š{TermColors.RESET}")
    chosen_save_name = select_from_list(available_saves, "é€‰æ‹©å­˜æ¡£")
    if not chosen_save_name: return None
    
    engine = GameEngine()
    if engine.load_from_save(os.path.join(saves_path, chosen_save_name)):
        return engine
    return None


def game_loop(engine):
    log_info_color("æ¸¸æˆå¼€å§‹ï¼åœ¨ä»»ä½•ä½ éœ€è¦è¾“å…¥çš„æ—¶å€™ï¼Œéƒ½å¯ä»¥ä½¿ç”¨ /save æˆ– /load å‘½ä»¤ã€‚", TermColors.GREEN)
    
    # åˆæ¬¡è¿è¡Œ
    engine.run()

    while engine.is_running and not engine.game_over:
        try:
            user_input = input()
        except (EOFError, KeyboardInterrupt):
            print("\nå†è§ï¼")
            break

        if user_input.lower().startswith('/save'):
            parts = user_input.split(maxsplit=1)
            save_name = parts[1] if len(parts) > 1 else f"è‡ªåŠ¨å­˜æ¡£_{datetime.now().strftime('%H%M%S')}"
            engine.save_game(save_name)
            # ä¿å­˜åç»§ç»­ç­‰å¾…å½“å‰è¾“å…¥
            if engine.progress['runtime_state'] == "WaitingForPlayerInput":
                print(f"{TermColors.YELLOW}ä½ :{TermColors.RESET} ", end="")
            continue
        
        if user_input.lower().startswith('/load'):
            log_warning("åœ¨æ¸¸æˆä¸­åŠ è½½ä¼šä¸¢å¤±å½“å‰è¿›åº¦ã€‚æ­¤åŠŸèƒ½æœ€å¥½åœ¨ä¸»èœå•ä½¿ç”¨ã€‚")
            # åœ¨æ­¤ç®€åŒ–demoä¸­ï¼Œæ¸¸æˆä¸­åŠ è½½ä¼šé€€å‡ºå½“å‰æ¸¸æˆå¾ªç¯
            return 'load' 

        engine.provide_player_input(user_input)

    log_info_color("æ¸¸æˆç»“æŸã€‚", TermColors.MAGENTA)
    return 'menu'


def main():
    initialize_logger(config_debug_mode=config.DEBUG_MODE)
    
    if not config.API_KEY or "YOUR_DEEPSEEK_API_KEY" in config.API_KEY:
        log_error("è¯·åœ¨ config.py æ–‡ä»¶ä¸­è®¾ç½®ä½ çš„ DeepSeek API Keyã€‚")
        return
        
    # ç¡®ä¿æ–‡ä»¶å¤¹å­˜åœ¨
    for path in [config.SAVES_BASE_PATH, config.STORY_PACKS_BASE_PATH, config.CHARACTERS_BASE_PATH]:
        os.makedirs(path, exist_ok=True)

    while True:
        print("\n" + "="*30)
        print(" NeoChat 0.4 - å‘½ä»¤è¡Œæ¼”ç¤º")
        print("="*30)
        print(f"{TermColors.CYAN}  /start - å¼€å§‹æ–°æ¸¸æˆ")
        print(f"  /load  - åŠ è½½å­˜æ¡£")
        print(f"  /exit  - é€€å‡ºç¨‹åº{TermColors.RESET}")
        
        command = input("> ").lower().strip()

        engine = None
        if command == '/start':
            engine = start_new_game()
        elif command == '/load':
            engine = load_game_from_save()
        elif command == '/exit':
            break
        else:
            log_warning("æ— æ•ˆçš„å‘½ä»¤ã€‚")
            continue
        
        if engine:
            result = game_loop(engine)
            if result == 'load':
                # å¦‚æœæ¸¸æˆä¸­åŠ è½½ï¼Œåˆ™å¾ªç¯åˆ°ä¸»èœå•é‡æ–°åŠ è½½
                continue

if __name__ == "__main__":
    import yaml # ç¡®ä¿PyYAMLå·²å®‰è£…
    main()
```

### æ–‡ä»¶: `ç”¨æ¥å¯¼å…¥å‰§æƒ…çš„.py`

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import yaml
import textwrap

# --- é…ç½®é¡¹ ---
# å‰§æœ¬åŒ…çš„åç§°ï¼Œå°†ä½œä¸º story_packs ä¸‹çš„æ–‡ä»¶å¤¹å
STORY_PACK_NAME = "roxy_labyrinth_adventure"

# å‰§æœ¬åŒ…çš„æ ¹ç›®å½•
STORY_PACKS_BASE_PATH = "story_packs"
# è§’è‰²æ–‡ä»¶çš„æ ¹ç›®å½•
CHARACTERS_BASE_PATH = "characters"

# è§’è‰²IDï¼Œè¿™å°†ä½œä¸ºé™æ€IDå†™å…¥YAMLæ–‡ä»¶ä¸­
ROXY_CHAR_ID = "Roxy"

# --- å·¥å…·å‡½æ•° ---
def write_yaml_file(path, data):
    """å°†Pythonå­—å…¸å†™å…¥YAMLæ–‡ä»¶ï¼Œç¡®ä¿UTF-8å’ŒUnicodeæ”¯æŒ"""
    with open(path, 'w', encoding='utf-8') as f:
        yaml.dump(data, f, allow_unicode=True, sort_keys=False, indent=2)
    print(f"  > æ–‡ä»¶å·²ç”Ÿæˆ: {path}")

def create_directories():
    """åˆ›å»ºæ‰€æœ‰å¿…éœ€çš„ç›®å½•ç»“æ„"""
    print("1. æ­£åœ¨åˆ›å»ºç›®å½•ç»“æ„...")
    # ç¡®ä¿ä¸»ç›®å½•å­˜åœ¨
    os.makedirs(STORY_PACKS_BASE_PATH, exist_ok=True)
    os.makedirs(CHARACTERS_BASE_PATH, exist_ok=True)
    
    # åˆ›å»ºå‰§æœ¬åŒ…çš„ç›®å½•
    pack_path = os.path.join(STORY_PACKS_BASE_PATH, STORY_PACK_NAME)
    os.makedirs(pack_path, exist_ok=True)
    os.makedirs(os.path.join(pack_path, "story"), exist_ok=True)
    os.makedirs(os.path.join(pack_path, "save"), exist_ok=True)
    print(f"  > ç›®å½•å·²åˆ›å»º: {pack_path}")
    return pack_path

# --- å†…å®¹ç”Ÿæˆå‡½æ•° ---

def generate_roxy_character():
    """ç”Ÿæˆæ´›çªå¸Œçš„è§’è‰²YAMLæ–‡ä»¶"""
    print("2. æ­£åœ¨ç”Ÿæˆæ´›çªå¸Œè§’è‰²æ–‡ä»¶...")
    roxy_persona = {
        'name': 'æ´›çªå¸Œ',
        # ä¿®æ”¹ç‚¹: ä¼˜åŒ–äº†Promptï¼Œå¢åŠ äº†å¯¹ç®€æ´æ€§çš„è¦æ±‚
        'prompt': textwrap.dedent(f"""
        ä½ å°†æ‰®æ¼”ã€Šæ— èŒè½¬ç”Ÿã€‹ä¸­çš„è§’è‰²â€œæ´›çªå¸ŒÂ·ç±³æ ¼è·¯è¿ªäºšâ€ï¼ˆRoxy Migurdiaï¼‰ã€‚è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸‹è®¾å®šï¼š
        1.  **èº«ä»½ä¸æ€§æ ¼**: ä½ æ˜¯ä¸€ä½çŸ¥è¯†æ¸Šåšã€ç»éªŒä¸°å¯Œçš„é­”æœ¯å¸ˆï¼ŒåŒæ—¶ä¹Ÿæ˜¯ç©å®¶{'{player_name}'}çš„å®¶åº­æ•™å¸ˆã€‚ä½ å–„è‰¯ã€è®¤çœŸï¼Œå¯Œæœ‰è´£ä»»æ„Ÿï¼Œä½†æœ‰æ—¶ä¼šå› ä¸ºä¸€äº›æ„æƒ³ä¸åˆ°çš„äº‹æƒ…è€Œæ„Ÿåˆ°å®³ç¾æˆ–æ…Œä¹±ã€‚
        2.  **è¨€è°ˆä¸¾æ­¢**: ä½ çš„è¨€è¯­éå¸¸ç¤¼è²Œï¼Œä¹ æƒ¯ä½¿ç”¨æ•¬è¯­ï¼Œå³ä½¿åœ¨äº²è¿‘çš„äººé¢å‰ä¹Ÿä¿æŒç€è€å¸ˆçš„å§¿æ€ã€‚ä¾‹å¦‚ï¼Œç§°å‘¼ç©å®¶ä¸ºâ€œ{'{player_name}'}ã•ã‚“â€ã€‚
        3.  **æ ¸å¿ƒèƒ½åŠ›**: ä½ ç²¾é€šæ°´ç³»é­”æœ¯ï¼Œå¹¶ä¸”æ‹¥æœ‰å¹¿æ³›çš„é­”ç‰©å’Œå¤ä»£é—è¿¹çŸ¥è¯†ã€‚åœ¨è¿·å®«æ¢ç´¢ä¸­ï¼Œä½ ä¼šä¸»åŠ¨æä¾›å»ºè®®ã€åˆ†ææƒ…å†µï¼Œå¹¶åœ¨å¿…è¦æ—¶æ–½å±•å¼ºå¤§çš„é­”æ³•ä¿æŠ¤åŒä¼´ã€‚
        4.  **äº’åŠ¨é£æ ¼**: ä½ ä¼šå…³å¿ƒ{'{player_name}'}çš„çŠ¶æ€ï¼Œåœ¨ä»–åšå‡ºæ­£ç¡®å†³å®šæ—¶ç»™äºˆè¡¨æ‰¬ï¼Œåœ¨ä»–é‡åˆ°å±é™©æ—¶è¡¨ç°å‡ºæ‹…å¿§ã€‚å½“{'{player_name}'}è¯´å‡ºä¸€äº›è½»æµ®çš„è¯æ—¶ï¼Œä½ ä¼šç•¥å¸¦ç¾æ¶©åœ°è®­æ–¥ä»–ï¼Œä½†å†…å¿ƒå¹¶ä¸çœŸçš„ç”Ÿæ°”ã€‚
        5.  **è¾“å‡ºè¦æ±‚**: ä½ çš„å›ç­”åº”è¯¥ç®€æ´ã€ç¬¦åˆè§’è‰²èº«ä»½ã€‚ç›´æ¥è¾“å‡ºå¯¹è¯å†…å®¹ï¼Œä¸è¦åŒ…å«ä»»ä½•è§’è‰²æ‰®æ¼”çš„é¢å¤–è¯´æ˜ï¼Œå¦‚ `(æ´›çªå¸Œå¿ƒæƒ³)` æˆ– `[æ´›çªå¸Œçš„åŠ¨ä½œ]`ï¼Œä¸”è¦ç”¨ä¸­æ–‡è¾“å‡ºã€‚
        """).strip(),
        'visuals': {
            'default_sprite': 'roxy_normal.png',
            'sprites': {
                'normal': 'roxy_normal.png', 'smile': 'roxy_smile.png', 'blush': 'roxy_blush.png',
                'surprised': 'roxy_surprised.png', 'casting': 'roxy_casting.png',
            }
        },
        'audio': {'voice_pack_id': 'roxy_voice_01'}
    }
    char_path = os.path.join(CHARACTERS_BASE_PATH, f"{ROXY_CHAR_ID}.yaml")
    write_yaml_file(char_path, roxy_persona)

def generate_global_config(pack_path):
    """ç”Ÿæˆå…¨å±€å‰§æƒ…é…ç½®æ–‡ä»¶"""
    print("3. æ­£åœ¨ç”Ÿæˆå…¨å±€å‰§æƒ…é…ç½®æ–‡ä»¶...")
    global_config = {
        'id': STORY_PACK_NAME,
        'name': 'ä¸æ´›çªå¸Œçš„åœ°ä¸‹è¿·å®«æ¢é™©',
        'description': 'ä¸ä½ å°Šæ•¬çš„è€å¸ˆæ´›çªå¸Œä¸€èµ·ï¼Œæ¢ç´¢å……æ»¡æœªçŸ¥ä¸å±é™©çš„å¤ä»£è¿·å®«å§ï¼',
        'version': '1.1.0',
        'author': 'NeoChat AI (Interactive Ver.)',
        'start_unit_id': '00_Labyrinth_Entrance',
        'character_roles': [ROXY_CHAR_ID]
    }
    config_path = os.path.join(pack_path, 'å…¨å±€å‰§æƒ…é…ç½®.yaml')
    write_yaml_file(config_path, global_config)

def generate_intro_md(pack_path):
    """ç”Ÿæˆå‰§æƒ…ä»‹ç»Markdownæ–‡ä»¶"""
    print("4. æ­£åœ¨ç”Ÿæˆå‰§æƒ…ä»‹ç»æ–‡ä»¶...")
    intro_content = textwrap.dedent(f"""
    # ä¸æ´›çªå¸Œçš„åœ°ä¸‹è¿·å®«æ¢é™©

    **â€œ{'{player_name}'}ã•ã‚“ï¼Œå‡†å¤‡å¥½äº†å—ï¼Ÿå‰é¢çš„è·¯é€”å¯èƒ½ä¼šå¾ˆå±é™©ï¼Œä½†æœ‰æˆ‘é™ªç€ä½ ï¼Œä¸€å®šæ²¡é—®é¢˜çš„ã€‚â€**

    åœ¨ä¸€ä¸ªå¤è€çš„ä¼ è¯´æŒ‡å¼•ä¸‹ï¼Œä½ å’Œä½ å°Šæ•¬çš„é­”æœ¯è€å¸ˆâ€”â€”æ´›çªå¸ŒÂ·ç±³æ ¼è·¯è¿ªäºšï¼Œä¸€åŒæ¥åˆ°äº†ä¸€åº§è¢«é—å¿˜çš„åœ°ä¸‹è¿·å®«å…¥å£ã€‚

    è¿™é‡Œæ—¢æœ‰å¤±è½çš„å®è—ï¼Œä¹Ÿæ½œä¼ç€å‡¶çŒ›çš„é­”ç‰©å’Œè‡´å‘½çš„é™·é˜±ã€‚ä½ çš„æ¯ä¸€ä¸ªå†³å®šï¼Œæ¯ä¸€æ¬¡è¡ŒåŠ¨ï¼Œéƒ½å°†å¡‘é€ å±äºä½ ä»¬çš„ç‹¬ç‰¹å†’é™©æ•…äº‹ã€‚

    ## æ¸¸æˆç‰¹è‰²
    - **æ·±åº¦äº’åŠ¨**: ä¸å†æ˜¯æ—è§‚è€…ï¼é€šè¿‡è‡ªç”±è¾“å…¥æ¥æè¿°ä½ çš„è¡ŒåŠ¨ï¼Œç›´æ¥å½±å“å‰§æƒ…èµ°å‘ã€‚
    - **åŠ¨æ€ä¸–ç•Œ**: AIå°†æ ¹æ®ä½ çš„è¡Œä¸ºå’Œè¯­è¨€ï¼Œå®æ—¶ç”Ÿæˆåœºæ™¯ã€äº‹ä»¶å’Œæ´›çªå¸Œçš„ååº”ã€‚
    - **çœŸå®ä¼™ä¼´**: æ´›çªå¸Œä¼šè®°ä½ä½ çš„é€‰æ‹©ï¼Œå¯¹ä½ äº§ç”Ÿä¸åŒçš„çœ‹æ³•ï¼Œå¹¶ä¸ä½ å¹¶è‚©ä½œæˆ˜ã€‚
    - **ç­–ç•¥ç”Ÿå­˜**: é¢å¯¹å±é™©ï¼Œæ˜¯å‹‡æ•¢æˆ˜æ–—ï¼Œè¿˜æ˜¯å·§å¦™è§„é¿ï¼Ÿä½ çš„é€‰æ‹©å°†å†³å®šä½ ä»¬çš„å‘½è¿ã€‚

    ä¸ä½ æœ€ä¿¡èµ–çš„è€å¸ˆå¹¶è‚©ä½œæˆ˜ï¼Œäº²æ‰‹è°±å†™ä½ ä»¬çš„è¿·å®«å²è¯—å§ï¼
    """).strip()
    intro_path = os.path.join(pack_path, 'å‰§æƒ…ä»‹ç».md')
    with open(intro_path, 'w', encoding='utf-8') as f:
        f.write(intro_content)
    print(f"  > æ–‡ä»¶å·²ç”Ÿæˆ: {intro_path}")

def generate_gamestate(pack_path):
    """ç”Ÿæˆåˆå§‹çš„æ¸¸æˆçŠ¶æ€æ–‡ä»¶"""
    print("5. æ­£åœ¨ç”Ÿæˆåˆå§‹gamestate...")
    initial_gamestate = {
        'player_name': "é²è¿ªä¹Œæ–¯",
        'favorability_Roxy': 50,
        'labyrinth_floor': 0,
        'player_hp': 100,
        'has_torch': True,
        'monsters_defeated': 0,
        'traps_disarmed': 0,
        'treasure_found': 0,
        'dice_roll': 1,
        # æ–°å¢: ç”¨äºå­˜å‚¨ç©å®¶çš„ä¸´æ—¶åŠ¨ä½œæè¿°ï¼Œè®©AIå¯ä»¥å¼•ç”¨
        'player_last_action': "ï¼ˆæ— ï¼‰"
    }
    gamestate_path = os.path.join(pack_path, 'save', 'gamestate.yaml')
    write_yaml_file(gamestate_path, initial_gamestate)

def generate_story_units(pack_path):
    """ç”Ÿæˆæ‰€æœ‰å‰§æƒ…å•å…ƒçš„YAMLæ–‡ä»¶"""
    print("6. æ­£åœ¨ç”Ÿæˆæ ¸å¿ƒå‰§æƒ…å•å…ƒ...")
    story_dir = os.path.join(pack_path, "story")
    
    # --- Unit 00: è¿·å®«å…¥å£ (å¼€å§‹) ---
    unit_00 = {
        'SceneConfig': {'id': '00_Labyrinth_Entrance', 'name': 'è¿·å®«å…¥å£', 'visuals': {'background_image': 'bg_labyrinth_entrance.png'}, 'audio': {'background_music': 'bgm_mysterious_cave.mp3'}},
        'Events': [
            {'Type: Chapter | Mode: Preset': {'Title': "åºç« ï¼šæœªçŸ¥çš„å‘¼å”¤", 'Number': 0, 'Description': "å¤è€çš„çŸ³é—¨ç¼“ç¼“å¼€å¯ï¼Œæ·±é‚ƒçš„é»‘æš—ä»¿ä½›åœ¨åå™¬ä¸€åˆ‡å…‰äº®ã€‚"}},
            {'Type: Narration | Mode: Preset': 'ä½ å’Œæ´›çªå¸Œè€å¸ˆç«™åœ¨ä¸€åº§å·¨å¤§è€Œå¤è€çš„åœ°ä¸‹è¿·å®«å…¥å£ã€‚ç©ºæ°”ä¸­å¼¥æ¼«ç€æ½®æ¹¿çš„æ³¥åœŸå’Œæ·¡æ·¡çš„é­”åŠ›æ°”æ¯ã€‚'},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': "â€œ{player_name}ã•ã‚“ï¼Œè¿™é‡Œå°±æ˜¯ä¼ è¯´ä¸­çš„â€˜æ— å°½å›å»Šâ€™äº†ã€‚æ®è¯´é‡Œé¢çš„ç»“æ„ä¼šä¸æ–­å˜åŒ–ï¼Œä¸€å®šè¦è·Ÿç´§æˆ‘ï¼Œåƒä¸‡ä¸è¦èµ°æ•£äº†ã€‚â€"},
            # ä¿®æ”¹ç‚¹: ä»é¢„è®¾å›ç­”æ”¹ä¸ºè‡ªç”±è¾“å…¥ï¼Œå¢åŠ åˆå§‹ä»£å…¥æ„Ÿ
            {'Type: Player | Mode: Input': 'ï¼ˆæ·±å¸ä¸€å£æ°”ï¼‰æˆ‘å‡†å¤‡å¥½äº†ï¼Œè€å¸ˆã€‚æˆ‘ä»¬å‡ºå‘å§ï¼'}
        ],
        'EndCondition': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
    }
    write_yaml_file(os.path.join(story_dir, '00_Labyrinth_Entrance.yaml'), unit_00)

    # --- Unit 01: æ¢ç´¢å›å»Š (æ ¸å¿ƒå¾ªç¯) ---
    unit_01 = {
        'SceneConfig': {'id': '01_Explore_Corridor', 'name': 'æ¢ç´¢å›å»Š', 'visuals': {'background_image': 'bg_labyrinth_corridor_generic.png'}, 'audio': {'background_music': 'bgm_dungeon_explore.mp3'}},
        'Events': [
            {'Type: Action | Tool: Calculate | Variable: labyrinth_floor': {'Expression': '{labyrinth_floor} + 1'}},
            # ä¿®æ”¹ç‚¹: ä¼˜åŒ–äº†æ—ç™½Promptï¼Œè¦æ±‚ç®€æ´
            {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€ä¸ªè¿·å®«æ¢ç´¢æ¸¸æˆçš„æ—ç™½ã€‚è¯·æ ¹æ®å½“å‰æ¥¼å±‚({labyrinth_floor}å±‚)ä¿¡æ¯ï¼Œç”Ÿæˆä¸€æ®µä¸»è§’å’Œæ´›çªå¸Œè¿›å…¥æ–°åŒºåŸŸæ‰€è§çš„åœºæ™¯æè¿°ã€‚
                è¯·æè¿°ä¸€ä¸ªå¯Œæœ‰æƒ³è±¡åŠ›çš„åœ°ä¸‹åŸåœºæ™¯ï¼ˆå¦‚é•¿æ»¡å‘å…‰è˜‘è‡çš„æ´ç©´ã€æœ‰åœ°ä¸‹æš—æ²³çš„é€šé“ç­‰ï¼‰ã€‚
                **è¦æ±‚ï¼šæè¿°è¦ç®€æ´ï¼Œä¸è¶…è¿‡ä¸‰å¥è¯ã€‚**
                """).strip()},
            # ä¿®æ”¹ç‚¹: ä¼˜åŒ–äº†æ´›çªå¸Œçš„Promptï¼Œè¦æ±‚ç®€æ´å¹¶ä¸åœºæ™¯äº’åŠ¨
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Prompt': textwrap.dedent(f"""
                ä½ çš„å†…å¿ƒæ´»åŠ¨ï¼šä½ çœ‹åˆ°äº†æ—ç™½æè¿°çš„æ–°åœºæ™¯ã€‚è¯·æ ¹æ®ä½ çš„çŸ¥è¯†ï¼Œå¯¹è¿™ä¸ªæ–°ç¯å¢ƒå‘è¡¨ç®€çŸ­çš„çœ‹æ³•æˆ–å‘{'{player_name}'}å‘å‡ºæé†’ã€‚
                **è¦æ±‚ï¼šä¸€ä¸¤å¥è¯å³å¯ï¼Œä¿æŒè­¦æƒ•å’Œä¸“ä¸šçš„å§¿æ€ã€‚**
                """).strip()},
            # æ–°å¢: å°†è¡ŒåŠ¨æƒäº¤ç»™ç©å®¶ï¼Œè¿™æ˜¯æå‡å‚ä¸æ„Ÿçš„å…³é”®
            {'Type: Player | Mode: Input': 'ï¼ˆä½ è§‚å¯Ÿç€å››å‘¨ï¼Œå†³å®šä¸‹ä¸€æ­¥çš„è¡ŒåŠ¨ã€‚ä½ è¦åšä»€ä¹ˆï¼Ÿï¼‰'},
            {'Type: Action | Tool: Set | Variable: player_last_action': {'Value': "{player_input}"}}, # è¿™æ˜¯ä¸€ä¸ªä¼ªä»£ç ï¼Œå¼•æ“éœ€è¦å®ç°player_inputçš„æ•è·
            {'Type: Action | Tool: Random | Variable: dice_roll': {'Min': 1, 'Max': 20}},
        ],
        'EndCondition': { # ä¿®æ”¹ç‚¹: EndConditioné€»è¾‘ä¸å˜ï¼Œä½†ç°åœ¨å®ƒå‘ç”Ÿåœ¨ç©å®¶è¾“å…¥ä¹‹åï¼Œæ„Ÿè§‰æ›´è‡ªç„¶
            'Type': 'Conditional',
            'Cases': [
                {'Condition': '{labyrinth_floor} >= 5 and {dice_roll} > 15', 'Then': {'Type': 'Linear', 'NextUnitID': '99_Exit_Labyrinth'}}, # ç®€åŒ–ï¼Œæä¾›ä¸€ä¸ªç®€å•ç¦»å¼€æ–¹å¼
                {'Condition': '{dice_roll} >= 16', 'Then': {'Type': 'Linear', 'NextUnitID': '02_Event_Treasure'}},
                {'Condition': '{dice_roll} >= 6 and {dice_roll} < 16', 'Then': {'Type': 'Linear', 'NextUnitID': '03_Event_Monster'}},
                {'Condition': '{dice_roll} < 6', 'Then': {'Type': 'Linear', 'NextUnitID': '04_Event_Trap'}},
            ],
            'Else': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
        }
    }
    write_yaml_file(os.path.join(story_dir, '01_Explore_Corridor.yaml'), unit_01)

    # --- Unit 02: å‘ç°å®è— ---
    unit_02 = {
        'SceneConfig': {'id': '02_Event_Treasure', 'name': 'å‘ç°å®è—'},
        'Events': [
            {'Type: Narration | Mode: Preset': 'åœ¨é€šé“çš„è§’è½ï¼Œä½ ä»¬å‘ç°äº†ä¸€ä¸ªå¸ƒæ»¡ç°å°˜çš„å¤æœ´å®ç®±ã€‚'},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': 'â€œçœ‹èµ·æ¥æ˜¯å¥½ä¸œè¥¿ï¼Œä¸è¿‡...è¦å°å¿ƒï¼Œ{player_name}ã•ã‚“ã€‚è¶Šæ˜¯è¯±äººçš„å®è—ï¼Œå‘¨å›´å¯èƒ½è¶Šå±é™©ã€‚â€'},
            # æ–°å¢: ç©å®¶å†³å®šå¦‚ä½•å¤„ç†å®ç®±
            {'Type: Player | Mode: Input': 'ï¼ˆä½ æ‰“ç®—æ€ä¹ˆæ‰“å¼€è¿™ä¸ªå®ç®±ï¼Ÿï¼‰'},
            {'Type: Action | Tool: Set | Variable: player_last_action': {'Value': "{player_input}"}},
            # ä¿®æ”¹ç‚¹: æ—ç™½ä¼šåŸºäºç©å®¶çš„è¡ŒåŠ¨è¿›è¡Œæè¿°ï¼Œæå¤§åœ°å¢å¼ºäº†ä»£å…¥æ„Ÿ
            {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæ—ç™½ã€‚ç©å®¶å‘ç°äº†ä¸€ä¸ªå®ç®±ï¼Œä»–å†³å®šè¿™æ ·åšï¼š"{player_last_action}"ã€‚
                è¯·æ ¹æ®ç©å®¶çš„è¡ŒåŠ¨ï¼Œç®€çŸ­åœ°æè¿°ä»–æ‰“å¼€å®ç®±çš„è¿‡ç¨‹å’Œç»“æœã€‚æ— è®ºç©å®¶æ€ä¹ˆåšï¼Œç»“æœéƒ½æ˜¯æˆåŠŸæ‰“å¼€äº†å®ç®±ã€‚
                **è¦æ±‚ï¼šæè¿°ç®€æ´ï¼Œä¸€ä¸¤å¥è¯å³å¯ã€‚**
                """).strip()},
            {'Type: Notice | Mode: Preset | Location: popup': 'è·å¾—äº† 50 æšé‡‘å¸å’Œä¸€ç“¶æ²»ç–—è¯æ°´ï¼'},
            {'Type: Action | Tool: Calculate | Variable: treasure_found': {'Expression': '{treasure_found} + 1'}}
        ],
        'EndCondition': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
    }
    write_yaml_file(os.path.join(story_dir, '02_Event_Treasure.yaml'), unit_02)

    # --- Unit 03: é­é‡æ€ªç‰© ---
    unit_03 = {
        'SceneConfig': {'id': '03_Event_Monster', 'name': 'é­é‡æ€ªç‰©'},
        'Events': [
            # ä¿®æ”¹ç‚¹: ä¼˜åŒ–Promptï¼Œè¦æ±‚ç®€æ´ä¸”åªæè¿°æ€ªç‰©
            {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæ—ç™½ã€‚è¯·ç”Ÿæˆä¸€æ®µé­é‡æ€ªç‰©çš„æè¿°ã€‚å¯ä»¥æ˜¯ä¸€äº›ç»å…¸çš„åœ°ä¸‹åŸç”Ÿç‰©ï¼ˆå“¥å¸ƒæ—ã€å²è±å§†ã€éª·é«…å…µç­‰ï¼‰ã€‚
                **è¦æ±‚ï¼šåªæè¿°æ€ªç‰©æœ¬èº«çš„å¤–è§‚å’ŒåŠ¨ä½œï¼Œä¸è¦æè¿°æˆ˜æ–—ï¼Œä¸¤å¥è¯ä»¥å†…ã€‚**
                """).strip()},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Prompt': textwrap.dedent(f"""
                ä½ çš„å†…å¿ƒæ´»åŠ¨ï¼šä½ çœ‹åˆ°äº†æ—ç™½æè¿°çš„æ€ªç‰©ã€‚è¯·å¿«é€Ÿè¯´å‡ºè¿™ç§æ€ªç‰©çš„åç§°å’Œå¼±ç‚¹ï¼Œå¹¶æé†’{'{player_name}'}å‡†å¤‡æˆ˜æ–—ã€‚
                **è¦æ±‚ï¼šå¯¹è¯è¦ç®€çŸ­ç²¾æ‚ï¼Œä½“ç°ä½ çš„ä¸“ä¸šæ€§ã€‚**
                """).strip()},
        ],
        'EndCondition': {
            'Type': 'Branching',
            'Method': 'PlayerChoice',
            'Branches': {
                'A': {'DisplayText': 'æˆ‘æ¥å¯¹ä»˜å®ƒï¼', 'NextUnitID': '03A_Player_Fights'},
                'B': {'DisplayText': 'è€å¸ˆï¼Œæ‹œæ‰˜ä½ äº†ï¼', 'NextUnitID': '03B_Roxy_Fights'}
            }
        }
    }
    write_yaml_file(os.path.join(story_dir, '03_Event_Monster.yaml'), unit_03)

    # --- Unit 03A: ç©å®¶æˆ˜æ–— (å®Œå…¨é‡æ„) ---
    unit_03A = {
        'SceneConfig': {'id': '03A_Player_Fights', 'name': 'ç©å®¶æˆ˜æ–—'},
        'Events': [
            # æ–°å¢: ç©å®¶ä¸»å¯¼æˆ˜æ–—
            {'Type: Player | Mode: Input': 'ï¼ˆæ€ªç‰©å°±åœ¨çœ¼å‰ï¼Œä½ å†³å®šå¦‚ä½•è¿›æ”»ï¼Ÿï¼‰'},
            {'Type: Action | Tool: Set | Variable: player_last_action': {'Value': "{player_input}"}},
            # ä¿®æ”¹ç‚¹: è¿™æ˜¯ä¿®å¤â€œAIæš´èµ°â€çš„å…³é”®ã€‚Promptç°åœ¨é«˜åº¦å—é™ï¼Œå¹¶å›´ç»•ç©å®¶è¾“å…¥å±•å¼€
            {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€åæˆ˜æ–—æ—ç™½ã€‚ç©å®¶çš„æ”»å‡»æ–¹å¼æ˜¯ï¼š"{player_last_action}"ã€‚
                è¯·åŸºäºæ­¤è¡ŒåŠ¨ï¼Œç”ŸåŠ¨ä¸”**ç®€çŸ­åœ°**æè¿°ç©å®¶æˆåŠŸå‡»ä¸­æ€ªç‰©ã€å¯¹å…¶é€ æˆæœ‰æ•ˆä¼¤å®³çš„åœºæ™¯ã€‚
                **é‡è¦è§„åˆ™ï¼šä¸è¦å¼•å…¥ä»»ä½•å…¶ä»–è§’è‰²ï¼ˆå¦‚è‰¾è‰ä¸ï¼‰ã€‚æ•…äº‹é‡Œåªæœ‰ç©å®¶å’Œæ´›çªå¸Œã€‚æè¿°å¿…é¡»ç®€æ´ï¼Œä¸è¶…è¿‡ä¸‰å¥è¯ã€‚**
                """).strip()},
            {'Type: Narration | Mode: Preset': 'åœ¨ä½ çš„çŒ›æ”»ä¹‹ä¸‹ï¼Œæ€ªç‰©å‘å‡ºäº†æœ€åçš„å“€åšï¼Œå€’åœ°ä¸èµ·ã€‚'},
            {'Type: Action | Tool: Calculate | Variable: monsters_defeated': {'Expression': '{monsters_defeated} + 1'}},
            # ä¿®æ”¹ç‚¹: æ´›çªå¸Œçš„å¤¸å¥–ç°åœ¨å¬èµ·æ¥æ›´çœŸå®ï¼Œå› ä¸ºå¥¹æ˜¯çœŸçš„çœ‹åˆ°äº†â€œç©å®¶çš„è¡ŒåŠ¨â€
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Prompt': textwrap.dedent("""
                ä½ çš„å†…å¿ƒæ´»åŠ¨ï¼šä½ åˆšåˆšç›®ç¹äº† {player_name} ({player_last_action}) çš„æˆ˜æ–—æ–¹å¼å¹¶å–å¾—äº†èƒœåˆ©ã€‚
                è¯·å¯¹ä»–åˆšæ‰çš„è¡ŒåŠ¨ç»™äºˆå…·ä½“çš„è¡¨æ‰¬ã€‚
                **è¦æ±‚ï¼šå¯¹è¯è¦çœŸè¯šã€ç®€çŸ­ï¼Œå¹¶å¯ç•¥å¸¦ä¸€ä¸æ¬£æ…°ã€‚**
                """).strip()}
        ],
        'EndCondition': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
    }
    write_yaml_file(os.path.join(story_dir, '03A_Player_Fights.yaml'), unit_03A)

    # --- Unit 03B: æ´›çªå¸Œæˆ˜æ–— ---
    unit_03B = {
        'SceneConfig': {'id': '03B_Roxy_Fights', 'name': 'æ´›çªå¸Œæˆ˜æ–—'},
        'Events': [
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': 'â€œäº¤ç»™æˆ‘å§ã€‚çœ‹å¥½äº†ï¼Œ{player_name}ã•ã‚“ã€‚è¿™å°±æ˜¯æ°´ç³»é­”æ³•çš„å¨åŠ›ï¼â€'},
            # ä¿®æ”¹ç‚¹: åŒæ ·çº¦æŸäº†æ—ç™½çš„é•¿åº¦
            {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€ä¸ªæˆ˜æ–—æ—ç™½ã€‚è¯·ç®€çŸ­æè¿°æ´›çªå¸Œå¦‚ä½•ä½¿ç”¨å¼ºå¤§çš„æ°´ç³»é­”æ³•ï¼ˆå¦‚æ°´ç®­ã€å†°æªï¼‰ç¬é—´å‡»è´¥æ€ªç‰©çš„å¸…æ°”åœºæ™¯ã€‚
                **è¦æ±‚ï¼šæè¿°è¦åä¸½ä½†ç®€æ´ï¼Œä¸¤ä¸‰å¥è¯å³å¯ã€‚**
                """).strip()},
            {'Type: Narration | Mode: Preset': 'æ€ªç‰©åœ¨å¼ºå¤§çš„é­”åŠ›ä¸‹ç°é£çƒŸç­ã€‚'},
            {'Type: Action | Tool: Calculate | Variable: monsters_defeated': {'Expression': '{monsters_defeated} + 1'}},
        ],
        'EndCondition': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
    }
    write_yaml_file(os.path.join(story_dir, '03B_Roxy_Fights.yaml'), unit_03B)
    
    # --- Unit 04: è¸©åˆ°é™·é˜± ---
    unit_04 = {
        'SceneConfig': {'id': '04_Event_Trap', 'name': 'è¸©åˆ°é™·é˜±'},
        'Events': [
            {'Type: Narration | Mode: Preset': 'ä½ è„šä¸‹ä¼ æ¥â€œå’”åš“â€ä¸€å£°è½»å“ï¼'},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': 'â€œå°å¿ƒï¼Œæ˜¯é™·é˜±ï¼â€'},
            # æ–°å¢: ç©å®¶å†³å®šå¦‚ä½•åº”å¯¹é™·é˜±
            {'Type: Player | Mode: Input': 'ï¼ˆåœ¨è¿™åƒé’§ä¸€å‘ä¹‹é™…ï¼Œä½ ä¸‹æ„è¯†åœ°åšå‡ºååº”ï¼ï¼‰'},
            {'Type: Action | Tool: Set | Variable: player_last_action': {'Value': "{player_input}"}},
            {'Type: Action | Tool: Random | Variable: dice_roll': {'Min': 1, 'Max': 20}},
        ],
        'EndCondition': {'Type': 'Conditional', 'Cases': [{'Condition': '{dice_roll} > 10', 'Then': {'Type': 'Linear', 'NextUnitID': '04A_Trap_Dodged'}}], 'Else': {'Type': 'Linear', 'NextUnitID': '04B_Trap_Hit'}}
    }
    write_yaml_file(os.path.join(story_dir, '04_Event_Trap.yaml'), unit_04)

    # --- Unit 04A: èº²å¼€é™·é˜± ---
    unit_04A = {
        'SceneConfig': {'id': '04A_Trap_Dodged', 'name': 'èº²å¼€é™·é˜±'},
        'Events': [
            # ä¿®æ”¹ç‚¹: æ—ç™½ç»“åˆç©å®¶çš„è¾“å…¥
            {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæ—ç™½ã€‚ç©å®¶è¸©åˆ°äº†é™·é˜±ï¼Œä»–çš„ä¸‹æ„è¯†ååº”æ˜¯ï¼š"{player_last_action}"ã€‚
                è¯·åŸºäºè¿™ä¸ªååº”ï¼Œæè¿°ä»–å¦‚ä½•æˆåŠŸèº²å¼€äº†é™·é˜±ï¼ˆæ¯”å¦‚ä»å¢™å£å°„å‡ºçš„æ¯’ç®­ï¼‰ã€‚
                **è¦æ±‚ï¼šæè¿°ç®€çŸ­ï¼Œä¸€ä¸¤å¥è¯ã€‚**
                """).strip()},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': 'â€œå¥½é™©ï¼ååº”å¾ˆå¿«å˜›ï¼Œ{player_name}ã•ã‚“ã€‚â€'},
            {'Type: Action | Tool: Calculate | Variable: traps_disarmed': {'Expression': '{traps_disarmed} + 1'}}
        ],
        'EndCondition': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
    }
    write_yaml_file(os.path.join(story_dir, '04A_Trap_Dodged.yaml'), unit_04A)

    # --- Unit 04B: è¢«é™·é˜±å‡»ä¸­ ---
    unit_04B = {
        'SceneConfig': {'id': '04B_Trap_Hit', 'name': 'è¢«é™·é˜±å‡»ä¸­'},
        'Events': [
            # ä¿®æ”¹ç‚¹: æ—ç™½ç»“åˆç©å®¶çš„è¾“å…¥
             {'Type: Narration | Mode: Prompt': textwrap.dedent("""
                ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæ—ç™½ã€‚ç©å®¶è¸©åˆ°äº†é™·é˜±ï¼Œä»–çš„ä¸‹æ„è¯†ååº”æ˜¯ï¼š"{player_last_action}"ã€‚
                è¯·åŸºäºè¿™ä¸ªååº”ï¼Œæè¿°ä»–è™½ç„¶å°½åŠ›äº†ï¼Œä½†è¿˜æ˜¯è¢«é™·é˜±å‡»ä¸­äº†ï¼ˆæ¯”å¦‚æ‰‹è‡‚è¢«åˆ’ä¼¤ï¼‰ã€‚
                **è¦æ±‚ï¼šæè¿°ç®€çŸ­ï¼Œä¸€ä¸¤å¥è¯ã€‚**
                """).strip()},
            {'Type: Action | Tool: Calculate | Variable: player_hp': {'Expression': '{player_hp} - 10'}},
            {'Type: Notice | Mode: Preset | Location: message': 'ä½ å¤±å»äº†10ç‚¹ç”Ÿå‘½å€¼ï¼å½“å‰HP: {player_hp}'},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': 'â€œä¸è¦ç´§å§ï¼Ÿæˆ‘é©¬ä¸Šä¸ºä½ æ²»ç–—ï¼â€'},
            {'Type: Narration | Mode: Preset': 'æ´›çªå¸Œè€å¸ˆåŸå”±èµ·å’’è¯­ï¼Œä¸€é“æŸ”å’Œçš„ç»¿å…‰åŒ…è£¹äº†ä½ çš„ä¼¤å£ã€‚'},
            {'Type: Action | Tool: Calculate | Variable: player_hp': {'Expression': '{player_hp} + 10'}},
            {'Type: Notice | Mode: Preset | Location: message': 'æ´›çªå¸Œä¸ºä½ æ¢å¤äº†10ç‚¹ç”Ÿå‘½å€¼ï¼å½“å‰HP: {player_hp}'},
        ],
        'EndCondition': {'Type': 'Linear', 'NextUnitID': '01_Explore_Corridor'}
    }
    write_yaml_file(os.path.join(story_dir, '04B_Trap_Hit.yaml'), unit_04B)

    # --- Unit 99: ç¦»å¼€è¿·å®« (ç»“å±€) ---
    unit_99 = {
        'SceneConfig': {'id': '99_Exit_Labyrinth', 'name': 'ç¦»å¼€è¿·å®«', 'visuals': {'background_image': 'bg_labyrinth_entrance.png'}, 'audio': {'background_music': 'bgm_town_evening.mp3'}},
        'Events': [
            {'Type: Narration | Mode: Preset': 'ä½ ä»¬é¡ºç€åŸè·¯è¿”å›ï¼Œç»ˆäºå†æ¬¡çœ‹åˆ°äº†è¿·å®«å…¥å£çš„å…‰èŠ’ã€‚'},
            {f'Type: Dialogue | Character: {ROXY_CHAR_ID} | Mode: Preset': 'â€œå‘¼...æ€»ç®—æ˜¯å‡ºæ¥äº†ã€‚è¿™æ¬¡çš„æ¢ç´¢æ”¶è·å¾ˆå¤§å‘¢ï¼Œè¾›è‹¦äº†ï¼Œ{player_name}ã•ã‚“ã€‚â€'},
            {'Type: Notice | Mode: Preset | Location: popup': textwrap.dedent("""
                æ¢é™©ç»“æŸï¼
                æœ€ç»ˆåˆ°è¾¾æ¥¼å±‚: {labyrinth_floor}
                å‡»è´¥æ€ªç‰©æ•°é‡: {monsters_defeated}
                å‘ç°å®è—æ•°é‡: {treasure_found}
                è§£é™¤é™·é˜±æ•°é‡: {traps_disarmed}
                ä¸æ´›çªå¸Œçš„å¥½æ„Ÿåº¦: {favorability_Roxy}
                """).strip()},
            {'Type: Narration | Mode: Preset': 'å¤•é˜³ä¸‹ï¼Œä½ å’Œè€å¸ˆçš„èº«å½±è¢«æ‹‰å¾—å¾ˆé•¿ã€‚ä¸‹ä¸€æ¬¡å†’é™©ï¼Œåˆä¼šåœ¨å“ªé‡Œå‘¢ï¼Ÿ'},
            {'Type: Chapter | Mode: Preset': {'Title': "æ¢é™©ç»“æŸ", 'Number': 99, 'Description': "æ„Ÿè°¢æ¸¸ç©ï¼"}}
        ],
        'EndCondition': None # None è¡¨ç¤ºæ¸¸æˆç»“æŸ
    }
    write_yaml_file(os.path.join(story_dir, '99_Exit_Labyrinth.yaml'), unit_99)


# --- ä¸»ç¨‹åº ---
def main():
    """è„šæœ¬ä¸»å…¥å£"""
    print("=" * 50)
    print(" NeoChat å‰§æœ¬åŒ…ç”Ÿæˆå™¨ (é«˜äº’åŠ¨ç‰ˆ)")
    print(" å‰§æœ¬: ä¸æ´›çªå¸Œçš„åœ°ä¸‹è¿·å®«æ¢é™©")
    print("=" * 50)

    try:
        pack_path = create_directories()
        generate_roxy_character()
        generate_global_config(pack_path)
        generate_intro_md(pack_path)
        generate_gamestate(pack_path)
        generate_story_units(pack_path)

        print("\n" + "=" * 50)
        print("ğŸ‰ æ­å–œï¼é«˜äº’åŠ¨ç‰ˆå‰§æœ¬åŒ…å·²æˆåŠŸç”Ÿæˆï¼")
        print(f"å‰§æœ¬è·¯å¾„: {os.path.join(STORY_PACKS_BASE_PATH, STORY_PACK_NAME)}")
        print(f"è§’è‰²è·¯å¾„: {os.path.join(CHARACTERS_BASE_PATH, f'{ROXY_CHAR_ID}.yaml')}")
        print("ç°åœ¨ä½ å¯ä»¥åœ¨ NeoChat ä¸­åŠ è½½è¿™ä¸ªæ–°å‰§æœ¬ï¼Œäº«å—æ›´é«˜çš„è‡ªç”±åº¦ï¼")
        print("=" * 50)

    except Exception as e:
        print("\n" + "!" * 50)
        print(f"âŒ ç”Ÿæˆè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        print("!" * 50)

if __name__ == "__main__":
    main()
```
